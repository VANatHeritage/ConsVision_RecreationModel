#--------------------------------------------------------------------------------------
# AssessRecOpps.py
# Version:  ArcGIS 10.3.1 / Python 2.7.8
# Creation Date: 2018-10-04
# Last Edit: 2018-10-04
# Creator:  Kirsten R. Hazler
#
# Summary:
# Assesses adequacy of recreation opportunities based on facilities' service areas, population, and specified benchmark standards.
#
# Usage:
# 
#--------------------------------------------------------------------------------------
# Import Helper module and functions
import Helper
from Helper import *
from arcpy import env

def CreateBenchmark(inPop, inVal, outBenchmark):
   '''Creates a raster indicating the desired level of recreational access, based on a per-person "rule of thumb" value and the population size. The output raster is a benchmark against which actual estimated recreation access is compared.
   
   inPop = input continuous raster representing population per pixel. This may have been generated by the "DistribPop" function, or other means. Pixel values should represent the number of persons within the pixel.
   
   inVal = input value representing the desired area (or length) of recreational facilities, per person. For parks, the value suggested is 0.010 acres/person (= 0.004 ha)
   
   outBenchmark = output raster with benchmark values for desired recreation access, weighted by population.
   '''
   
   # Apply environment settings
   arcpy.env.extent = inPop
   arcpy.env.mask = inPop
   
   # Calculate benchmark raster
   printMsg('Calculating benchmark raster.')
   expression = '"%s" * float(%s)' % (inPop, str(inVal))
   arcpy.gp.RasterCalculator_sa(expression, outBenchmark)
   
   return outBenchmark

def QuantRecOpps(inDir, inPop, outOppsPP, outRecOpps, tmpDir, zeroRast = ''):
   '''Quantifies recreation opportunities accessed, based on facilities' service areas and population.
   
   inDir = input folder containing service area rasters to be processed. It is assumed these are continuous rasters in TIF format. Each service area should be coded with the value (e.g., area or trail length) of the entity, and the raster should be coded NoData (null) outside the service area.
   
   inPop = input continuous raster representing population per pixel. This may have been generated by the "DistribPop" function, or other means. Pixel values should represent the number of persons within the pixel.
   
   outRecPP = output raster representing per-person sum of available recreation access (area or length)
   
   outRecOpps = output raster representing population-weighted sum of available recreation access (area or length). This is the raster to be compared against the benchmark raster.
   
   tmpDir = directory to contain temporary outputs
   
   zeroRast = a raster coded with zeros whereever the "inPop" raster is non-null
   '''
   
   # Apply environment settings
   arcpy.env.snapRaster = inPop
   arcpy.env.cellSize = inPop
   arcpy.env.extent = inPop
   arcpy.env.mask = inPop
   
   # Set up some output variables
   if zeroRast == '':
      zeroRast = tmpDir + os.sep + 'zeros.tif'
      
   # Create baseline zeros raster
   if arcpy.Exists(zeroRast):
      printMsg('Zero raster already exists. Proceeding to next step...')
   else:
      printMsg('Creating zero raster...')
      expression = 'Con("%s",0)' % inPop
      arcpy.gp.RasterCalculator_sa(expression, zeroRast)
      printMsg('Zero raster created.')
      
   # Initialize some objects
   arcpy.env.workspace = inDir
   ServAreas = arcpy.ListRasters() # List of service areas to process
   myRastList = [zeroRast] # List to store paths to rasters to be summed
   myFailList = [] # List to store names of rasters failing to be processed
   myIndex = 1 # counter
   
   # For each service area:
   for sa in ServAreas:
      try:
         arcpy.env.extent = sa
         printMsg('Working on %s...' % sa) 
      
         # Integerize the service area
         expression = 'Con("%s",1)' % sa
         intSA = tmpDir + os.sep + "intSA.tif"
         arcpy.gp.RasterCalculator_sa(expression, intSA)
         printMsg('Service area integerized.')

         # Get sum of population within service area
         sumPop = tmpDir + os.sep + "sumPop.tif"
         arcpy.gp.ZonalStatistics_sa(intSA, "Value", inPop, sumPop, "SUM", "DATA") 
         printMsg('Population summed.')
         
         # Get the recreation area (or length) per person
         expression = '"%s"/"%s"' % (sa, sumPop )
         recPP = tmpDir + os.sep + "recPP_%05d.tif" % myIndex
         arcpy.gp.RasterCalculator_sa(expression, recPP)
         printMsg('Per person rec opps calculated.')
         
         myRastList.append(recPP)
         printMsg('Processing for %s complete.' % sa)
         
      except:
         printMsg('Processing for %s failed.' % sa)
         myFailList.append(sa)
         
      finally:
         myIndex += 1
         try:
            del sa, intSA, sumPop, recPP
         except:
            pass
   
   # Sum the areas (or lengths) accessed per person
   printMsg('Summing all rasters to get per-person recreation access. This will take awhile...')
   arcpy.env.extent = inPop
   newSum = CellStatistics (myRastList, "SUM", "DATA")
   arcpy.CopyRaster_management (newSum, outOppsPP) 
   printMsg('Finished summing rasters.')
   
   # Calculate the population-weighted areas (or lengths) accessed
   printMsg('Calculating population-weighted recreation access...')
   expression = '"%s" * "%s"' % (inPop, outOppsPP)
   arcpy.gp.RasterCalculator_sa(expression, outRecOpps)
   printMsg('Mission accomplished.')
   
   return (outOppsPP, outRecOpps)
   
def AssessRecOpps(inBenchmark, inRecOpps, outRecAssessment):
   '''Compares estimated recreation access to a benchmark to determine where recreation resources meet or exceed desired levels, and where attention is needed to offer additional resources.
   
   inBenchmark = input raster with benchmark values for desired recreation access (area or length), weighted by population.
   
   inRecOpps = input raster representing population-weighted sum of available recreation access (area or length). 
   
   outRecAssessment = out raster representing the difference between the desired condition (benchmark) and estimated actual condition of recreation access
   '''
   
   printMsg('Comparing recreation access to benchmark by subraction...')
   expression = '"%s" - "%s"' % (inBenchmark, inRecOpps)
   arcpy.gp.RasterCalculator_sa(expression, outRecAssessment)
   
   # Possibly add further steps here to classify and symbolize output?
   
   printMsg('Finished.')
   return outRecAssessment
   
# Use the main function below to run functions directly from Python IDE or command line with hard-coded variables

def main():
   # Set up variables
   inPop = r'C:\Users\xch43889\Documents\Working\ConsVision\RecMod\TIF_VALAM\distribPop_noZeros.tif'
   inVal = 0.004
   outBenchmark = r'C:\Users\xch43889\Documents\Working\ConsVision\RecMod\TIF_VALAM\terrAreaBenchmark.tif'
   inDir = r'C:\Users\xch43889\Documents\Working\ConsVision\RecMod\example_serviceareas'
   outOppsPP = r'C:\Users\xch43889\Documents\Working\ConsVision\RecMod\TIF_VALAM\outOppsPP.tif'
   outRecOpps = r'C:\Users\xch43889\Documents\Working\ConsVision\RecMod\TIF_VALAM\outRecOpps.tif'
   tmpDir = r'C:\Users\xch43889\Documents\Working\ConsVision\RecMod\TMP'
   outRecAssessment = r'C:\Users\xch43889\Documents\Working\ConsVision\RecMod\TIF_VALAM\outRecAsmt.tif'
      
   # Specify function(s) to run
   # CreateBenchmark(inPop, inVal, outBenchmark)
   # QuantRecOpps(inDir, inPop, outOppsPP, outRecOpps, tmpDir, zeroRast = '')
   AssessRecOpps(outBenchmark, outRecOpps, outRecAssessment)
   

if __name__ == '__main__':
   main()
