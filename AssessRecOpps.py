#--------------------------------------------------------------------------------------
# AssessRecOpps.py
# Version:  ArcGIS 10.3.1 / Python 2.7.8
# Creation Date: 2018-10-04
# Last Edit: 2019-02-22
# Creator:  Kirsten R. Hazler
#
# Summary:
# Assesses adequacy of recreation opportunities based on facilities' service areas, population, and specified benchmark standards.
#
# Usage:
# 
#--------------------------------------------------------------------------------------
# Import Helper module and functions
import Helper
from Helper import *
from arcpy import env

def QuantRecOpps(inDir, inPop, outRecPP, tmpDir, zeroRast = ''):
   '''Quantifies recreation opportunities accessed per person, based on facilities' service areas and population.
   
   inDir = input folder containing service area rasters to be processed. It is assumed these are continuous rasters in TIF format. Each service area should be coded with the value (e.g., area or trail length) of the entity, and the raster should be coded NoData (null) outside the service area.
   
   inPop = input continuous raster representing population per pixel. This may have been generated by the "DistribPop" function, or other means. Pixel values should represent the number of persons within the pixel.
   
   outRecPP = output raster representing per-person sum of available recreation access (area or length)
   
   [eliminated variable] outRecOpps = output raster representing population-weighted sum of available recreation access (area or length). This is the raster to be compared against the benchmark raster.
   
   tmpDir = directory to contain temporary outputs
   
   zeroRast = a raster coded with zeros whereever the "inPop" raster is non-null
   '''
   
   # Apply environment settings
   arcpy.env.snapRaster = inPop
   arcpy.env.cellSize = inPop
   arcpy.env.extent = inPop
   arcpy.env.mask = inPop
   
   # Set up some output variables
   if zeroRast == '':
      zeroRast = tmpDir + os.sep + 'zeros.tif'
      
   # Create baseline zeros raster
   if arcpy.Exists(zeroRast):
      printMsg('Zero raster already exists. Proceeding to next step...')
   else:
      printMsg('Creating zero raster...')
      tmpRast = Con(inPop, 0)
      tmpRast.save(zeroRast)
      printMsg('Zero raster created.')
      
   # Initialize some objects
   arcpy.env.workspace = inDir
   ServAreas = arcpy.ListRasters() # List of service areas to process
   myRastList = [zeroRast] # List to store paths to rasters to be summed
   myFailList = [] # List to store names of rasters failing to be processed
   myIndex = 1 # counter
   
   # For each service area:
   for sa in ServAreas:
      try:
         arcpy.env.extent = sa
         printMsg('Working on %s...' % sa) 
      
         # Integerize the service area
         intSA = tmpDir + os.sep + "intSA.tif"
         tmpRast = Con(sa,1)
         tmpRast.save(intSA)
         printMsg('Service area integerized.')

         # Get sum of population within service area
         sumPop = tmpDir + os.sep + "sumPop.tif"
         tmpRast = ZonalStatistics(intSA, "Value", inPop, "SUM", "DATA") 
         tmpRast.save(sumPop)
         printMsg('Population summed.')
         
         # Get the recreation area (or length) per person
         recPP = tmpDir + os.sep + "recPP_%05d.tif" % myIndex
         tmpRast = Raster(sa)/Raster(sumPop)
         tmpRast.save(recPP)
         printMsg('Per person rec opps calculated.')
         
         myRastList.append(recPP)
         printMsg('Processing for %s complete.' % sa)
         
      except:
         printMsg('Processing for %s failed.' % sa)
         myFailList.append(sa)
         
      finally:
         myIndex += 1
         try:
            del sa, intSA, sumPop, recPP
         except:
            pass
   
   # Sum the areas (or lengths) accessed per person
   printMsg('Summing all rasters to get per-person recreation access. This will take awhile...')
   arcpy.env.extent = inPop
   tmpRast = CellStatistics(myRastList, "SUM", "DATA")
   tmpRast.save(outRecPP)
   printMsg('Finished summing rasters.')
   
   # # Calculate the population-weighted areas (or lengths) accessed
   # printMsg('Calculating population-weighted recreation access...')
   # tmpRast = Raster(inPop)* Raster(outRecPP)
   # tmpRast.save(outRecOpps)
   printMsg('Mission accomplished.')
   
   return outRecPP
   
def AssessRecOpps(inBenchVal, inPop, inRecPP, inPubAccess, outDir, outBasename, inMask = None):
   '''Compares estimated recreation access to a benchmark to determine where recreation resources meet or exceed desired levels, and where attention is needed to offer additional resources.
   
   inBenchVal = input value representing the desired area (or length) of recreational facilities, per person. 
      For parks, the value suggested is 10 acres per 1000 people = 0.010 acres/person = 0.004 ha/person. This is based on communications with DCR-PRR staff; see "rule of thumb" email chain started 10/3/2018
      
      For trails, the value suggested is 1 mile per 2500 people = 1.61 km per 2500 people = 0.0006 km/person. This is based on the "Trails, Nature" line item in a chart provided by DCR-PRR staff; see email from J. Wampler on 10/5/2018.
   
   inPop = input continuous raster representing population per pixel. This may have been generated by the "DistribPop" function, or by other means. Pixel values should represent the number of persons within the pixel.
   
   inRecPP = input raster representing per-person sum of available recreation access (area or length)
   
   inPubAccess = input raster indicating public lands with any value; all other pixels must be null
   
   outDir = directory to contain output products
   
   outBasename = basename (string) for output products
   
   inMask = (optional) mask used to determine processing area
   '''
   
   if inMask:
      arcpy.env.mask = inMask
   
   RecPP = outDir + os.sep + outBasename + "_RecPP.tif"
   if arcpy.Exists(RecPP):
      printMsg('Per-person recreation raster already exists. Proceeding to next step...')
   else:
      printMsg('Updating per-person recreation raster...')
      tmpRast0 = Con(IsNull(inRecPP), 0, inRecPP)
      tmpRast0.save(RecPP)
   
   printMsg('Calculating the Recreation Access Score...')
   # Note: With this formula, a pixel just meeting the minimum standard will get a score of 20. Anything meeting or exceeding five times the standard will get the maximum score of 100.
   tmpRast1 = 100*Raster(RecPP)/(5*float(inBenchVal))
   tmpRast2 = Con(IsNull(inPubAccess),(Con(tmpRast1 > 100, 100, tmpRast1)), 101)
   RecScore = outDir + os.sep + outBasename + "_RecScore.tif"
   tmpRast2.save(RecScore)
   
   printMsg('Calculating the Recreation Need...')
   tmpRast3 = Con(Raster(RecScore) < 20, Raster(inPop) * (float(inBenchVal) - Raster(RecPP)))
   RecNeed = outDir + os.sep + outBasename + "_RecNeed.tif"
   tmpRast3.save(RecNeed)
   
   # Possibly add further steps here to classify and symbolize output?
   
   printMsg('Finished.')
   return (RecScore, RecNeed)
   
def TravelAccess(inTargets, inCostSurf, inSnapRaster, inMask, outTravTime, outScore, minTime = 10, maxTime = 30, limitTime = 30):
   '''Given input targets (e.g., public access lands or trails) and a cost surface, generates a raster representing the travel time in minutes to the nearest target. Also creates a score raster by linearly rescaling the travel time raster to a score from 0 to 100. Intended for use to determine local, pedestrian access.
   Parameters:
   - inTargets = Input point, line or polygon feature class representing targets to be accessed
   - inCostSurf = Input raster representing the time, in minutes, required to travel 1 meter
   - inSnapRaster = Input raster used to define coordinate system, cell size, and pixel alignment
   - inMask = Input raster or feature class used to define processing extent and analysis area
   - outTravTime = Output raster representing travel time, in minutes, to nearest target
   - outScore = Output raster representing travel time as a score from 0 to 100
   - minTime = Travel time, in minutes, below which the score should be set to 100
   - maxTime = Travel time, in minutes, above which the score should be set to 0
   - limitTime = Maximum travel time, in minutes, to be used in analysis. Any pixel more than this travel time from a target will have NoData in the OutTravTime raster, and will be set to zero in the OutScore raster
   '''
   
   # Set up processing environment
      arcpy.env.extent = inMask
      arcpy.env.mask = inMask
      arcpy.env.cellSize = inSnapRaster
      arcpy.env.snapRaster = inSnapRaster
      cellSize = arcpy.env.cellSize
      scratchGDB = arcpy.env.scratchGDB
      printMsg('Scratch products are being written to %s' %scratchGDB)
   
   # Convert features to raster according to shape type
   arcpy.AddField_management (inTargets, "RasterVal", "SHORT")
   arcpy.CalculateField_management (inTargets, "RasterVal", "1")
   Targets = scratchGDB + os.sep + 'Targets'
   desc = arcpy.Describe(inTargets)
   shapeType = desc.shapeType
   if shapeType in ('Point, Multipoint'):
      arcpy.PointToRaster_conversion (inTargets, "RasterVal", Targets, "MAXIMUM", "RasterVal", cellSize)
   elif shapeType == 'Polyline':
      PolylineToRaster_conversion (inTargets, "RasterVal", Targets, "MAXIMUM_COMBINED_LENGTH", "RasterVal", cellSize)
   elif shapeType == 'Polygon':
      arcpy.PolygonToRaster_conversion (inTargets, "RasterVal", Targets, "MAXIMUM_COMBINED_AREA", "RasterVal", cellSize)
   else:
      printErr('Not sure to do with this feature type. Aborting...')
      
   # Determine travel time to targets
   travTime = CostDistance (Targets, inCostSurf, limitTime)
   travTime.save(outTravTime)
   
   # Convert travel times to scores
   score = Con((travTime < minTime),100,Con((travTime > maxTime),0, 100*((maxTime - travTime)/(maxTime - minTime))))
   scoreNoNulls = Con(IsNull(score),0,score)
   scoreNoNulls.save(outScore)
   
   return (outTravTime, outScore)     

def GenRecNeed(inMask, inRecNeed, outDir, outBasename):
   '''Generalizes the Recreation Need Raster
   inMask = 
   
   inRecNeed = input Recreation Need raster (generated by the AssessRecOpps function)
   
   outDir =
   
   outBasename = 
  
   '''
   
   arcpy.env.mask = inMask
   RecNeed = outDir + os.sep + outBasename + "_RecNeedx1000.tif"
   if arcpy.Exists(RecNeed):
      printMsg('Integerized Recreation Need raster already exists. Proceeding to next step...')
   else:
      printMsg('Integerizing Recreation Need raster...')
      tmpRast1 = Con(IsNull(inRecNeed), 0, Int(0.5 + 1000 * Raster(inRecNeed)))
      tmpRast1.save(RecNeed)
      
   printMsg('Creating heat map of recreation need...')
   RecNeedHeat = outDir + os.sep + outBasename + "_RecNeedHeat_sum5Kx1000.tif"
   tmpRast2 = FocalStatistics(RecNeed, "Circle 5000 MAP", "SUM", "DATA")
   #tmpRast3 = tmpRast2/1000
   tmpRast2.save(RecNeedHeat)

   printMsg('Finished.')
   
def main():
   # Kirsten's Stuff
   # Set up variables
   inTargets = r'F:\Working\RecMod\FinalDataToUse\rec_source_datasets.gdb\pub_lands_final_20190221'
   inCostSurf = r'F:\Working\RecMod\FinalDataToUse\cost_surfaces_Tiger_2018\cost_surfaces.gdb\costSurf_walk'
   inSnapRaster = r'F:\Working\Snap_AlbersCONUS30\Snap_AlbersCONUS30.tif'
   inMask = r'F:\Working\VA_Buff50mi\VA_Buff50mi.shp'
   outTravTime = r'F:\Working\RecMod\Outputs\WalkTimeParks.tif'
   outScore = r'F:\Working\RecMod\Outputs\WalkScoreParks.tif'
   
   # Specify function(s) to run
   TravelAccess(inTargets, inCostSurf, inSnapRaster, inMask, outTravTime, outScore, minTime = 10, maxTime = 30, limitTime = 30)

if __name__ == '__main__':
   main()
