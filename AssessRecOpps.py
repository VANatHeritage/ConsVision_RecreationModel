#--------------------------------------------------------------------------------------
# AssessRecOpps.py
# Version:  ArcGIS 10.3.1 / Python 2.7.8
# Creation Date: 2018-10-04
# Last Edit: 2019-03-04
# Creator:  Kirsten R. Hazler
#
# Summary:
# Assesses adequacy of recreation opportunities based on facilities' service areas, population, and specified benchmark standards.
#
# Usage:
# 

# TO DO: 
# - Change all outputs to go into a FGDB. Some operations (notably, focal statistics) fail when outputting to TIF!
# - Add option for a multiplier and integerization to focalSum function. Focal statistics can fail miserably depending on values in input raster. For local RecNeed, I multiplied by 1000 and integerized to get it to work properly.
#--------------------------------------------------------------------------------------
# Import Helper module and functions
import Helper
from Helper import *
from arcpy import env

def FeatToRaster(inFeatures, inSnapRaster, inMask, outRaster):
   '''Given point, line, or polygon features, generates a raster representing those features
   Parameters:
   - inFeatures = Input point, line, or polygon feature class
   - inSnapRaster = Input raster used to define coordinate system, cell size, and pixel alignment
   - inMask = Input raster or feature class used to define processing extent and analysis area
   - outRaster = Output raster representing input features
   '''
   
   # Set up processing environment
   arcpy.env.extent = inMask
   arcpy.env.mask = inMask
   arcpy.env.cellSize = inSnapRaster
   arcpy.env.snapRaster = inSnapRaster
   cellSize = arcpy.env.cellSize
   scratchGDB = arcpy.env.scratchGDB
   printMsg('Scratch products are being written to %s' %scratchGDB)
   
   # Convert features to raster according to shape type
   printMsg('Converting features to a raster...')
   arcpy.AddField_management (inFeatures, "RasterVal", "SHORT")
   arcpy.CalculateField_management (inFeatures, "RasterVal", "1", "PYTHON")
   desc = arcpy.Describe(inFeatures)
   shapeType = desc.shapeType
   if shapeType in ('Point, Multipoint'):
      arcpy.PointToRaster_conversion (inFeatures, "RasterVal", outRaster, "MAXIMUM", "RasterVal", cellSize)
   elif shapeType == 'Polyline':
      arcpy.PolylineToRaster_conversion (inFeatures, "RasterVal", outRaster, "MAXIMUM_COMBINED_LENGTH", "RasterVal", cellSize)
   elif shapeType == 'Polygon':
      arcpy.PolygonToRaster_conversion (inFeatures, "RasterVal", outRaster, "MAXIMUM_COMBINED_AREA", "RasterVal", cellSize)
   else:
      printErr('Not sure to do with this feature type. Aborting...')
      
   printMsg('Finished.')
   
   return outRaster

   
def QuantRecOpps(inDir, inPop, outRecPP, tmpDir, zeroRast = ''):
   '''Quantifies recreation opportunities accessed per person, based on facilities' service areas and population.
   
   inDir = input folder containing service area rasters to be processed. It is assumed these are continuous rasters in TIF format. Each service area should be coded with the value (e.g., area or trail length) of the entity, and the raster should be coded NoData (null) outside the service area.
   
   inPop = input continuous raster representing population per pixel. This may have been generated by the "DistribPop" function, or other means. Pixel values should represent the number of persons within the pixel.
   
   outRecPP = output raster representing per-person sum of available recreation access (area or length)
   
   [eliminated variable] outRecOpps = output raster representing population-weighted sum of available recreation access (area or length). This is the raster to be compared against the benchmark raster.
   
   tmpDir = directory to contain temporary outputs
   
   zeroRast = a raster coded with zeros whereever the "inPop" raster is non-null
   '''
   
   # Apply environment settings
   arcpy.env.snapRaster = inPop
   arcpy.env.cellSize = inPop
   arcpy.env.extent = inPop
   arcpy.env.mask = inPop
   
   # Set up some output variables
   if zeroRast == '':
      zeroRast = tmpDir + os.sep + 'zeros.tif'
      
   # Create baseline zeros raster
   if arcpy.Exists(zeroRast):
      printMsg('Zero raster already exists. Proceeding to next step...')
   else:
      printMsg('Creating zero raster...')
      tmpRast = Con(inPop, 0)
      tmpRast.save(zeroRast)
      printMsg('Zero raster created.')
      
   # Initialize some objects
   arcpy.env.workspace = inDir
   ServAreas = arcpy.ListRasters() # List of service areas to process
   myRastList = [zeroRast] # List to store paths to rasters to be summed
   myFailList = [] # List to store names of rasters failing to be processed
   myIndex = 1 # counter
   
   # For each service area:
   for sa in ServAreas:
      try:
         arcpy.env.extent = sa
         printMsg('Working on %s...' % sa) 
      
         # Integerize the service area
         intSA = tmpDir + os.sep + "intSA.tif"
         tmpRast = Con(sa,1)
         tmpRast.save(intSA)
         printMsg('Service area integerized.')

         # Get sum of population within service area
         sumPop = tmpDir + os.sep + "sumPop.tif"
         tmpRast = ZonalStatistics(intSA, "Value", inPop, "SUM", "DATA") 
         tmpRast.save(sumPop)
         printMsg('Population summed.')
         
         # Get the recreation area (or length) per person
         recPP = tmpDir + os.sep + "recPP_%05d.tif" % myIndex
         tmpRast = Raster(sa)/Raster(sumPop)
         tmpRast.save(recPP)
         printMsg('Per person rec opps calculated.')
         
         myRastList.append(recPP)
         printMsg('Processing for %s complete.' % sa)
         
      except:
         printMsg('Processing for %s failed.' % sa)
         myFailList.append(sa)
         
      finally:
         myIndex += 1
         try:
            del sa, intSA, sumPop, recPP
         except:
            pass
   
   # Sum the areas (or lengths) accessed per person
   printMsg('Summing all rasters to get per-person recreation access. This will take awhile...')
   arcpy.env.extent = inPop
   tmpRast = CellStatistics(myRastList, "SUM", "DATA")
   tmpRast.save(outRecPP)
   printMsg('Finished summing rasters.')
   
   # # Calculate the population-weighted areas (or lengths) accessed
   # printMsg('Calculating population-weighted recreation access...')
   # tmpRast = Raster(inPop)* Raster(outRecPP)
   # tmpRast.save(outRecOpps)
   printMsg('Mission accomplished.')
   
   return outRecPP
   
def AssessRecNeed(inHex, hexFld, inBenchVal, inPop, inRecPP, inMask, outGDB, outBasename, inBenchMax = 5, remNulls = 0, multiplier = 10000, outHex = None):
   '''Compares estimated recreation access (in terms of acreage of parks, mileage of trails, or numbers of access points) to benchmarks to determine where recreation resources meet desired levels, and where attention is needed to offer additional resources.
   Parameters:
   - inHex = Input feature class with hexagons (or other regular polygons) for which raster values will be aggregated. It is assumed that this matches the coordinate system of input rasters.
   - hexFld = Field in inHex with unique IDs for each polygon
   - inBenchVal = Input value representing the desired area (or length) of recreational facilities, per person. 
      For regional parks, the value suggested is 10 acres per 1000 people = 0.010 acres/person = 0.004 ha/person. This is based on communications with DCR-PRR staff; see "rule of thumb" email chain started 10/3/2018
      
      For trails, the value suggested is 1 mile per 2500 people = 1.61 km per 2500 people = 0.0006 km/person. This is based on the "Trails, Nature" line item in a chart provided by DCR-PRR staff; see email from J. Wampler on 10/5/2018.
   - inPop = input continuous raster representing population per pixel. This may have been generated by the "DistribPop" function, or by other means. Pixel values should represent the number of persons within the pixel.
   - inRecPP = Input raster representing per-person sum of available recreation access (area or length)
   - inMask = mask used to determine processing area. Best to standard raster processing boundary.
   - outGDB = Geodatabase to contain output products
   - outHex = Output feature class with attributed hexagaons. If None, the original input feature class will be altered.
   - outBasename = Basename (string) for output products
   - inBenchMax = Multiplier by which inBenchVal is multiplied to obtain a standard for "excellent"
   - remNulls = Specifies whether inRecPP needs nulls to be removed. Options: 1 = Nulls need to be removed (typical for regional input if not pre-processed); 0 = Nulls do not need to be removed (typical for local input; default)
   - multiplier = Value by which to multiply per-person recreation access values to avoid failure during zonal statistics calculation
   - outHex = Output feature class with attributed hexagon. If "None" is specified, attributes will be added to the input feature class, and no new feature class will be created.
   '''
   
   if outHex != None:
      printMsg('Copying input polygons to fresh output...')
      arcpy.Copy_management (inHex, outHex)
      hexes = outHex
   else:
      hexes = inHex
   
   arcpy.env.extent = inMask
   arcpy.env.mask = inMask
   arcpy.env.snapRaster = inRecPP
   scratchGDB = arcpy.env.scratchGDB
   
   if remNulls == 1:
      printMsg('Updating per-person recreation raster to eliminate nulls in populated areas...')
      RecPP = outGDB + os.sep + outBasename + "_RecPP"
      ppNoNulls = Con(Raster(inPopSum)>0, Con(IsNull(inRecPP), 0, inRecPP))
      ppNoNulls.save(RecPP)
   else:
      printMsg('Assuming input per-person recreation raster has no nulls to remove. Proceeding...')
      RecPP = inRecPP
   
   # Calculate need rasters
   # Need is the amount of acres of parks, miles of trails, or numbers of aquatic access points needed to meet the benchmark for the number of people
   printMsg('Calculating the difference between recreation access and baseline benchmark...')
   # Note: Anyplace where the local population sum is 0 is considered to have no need and assigned the value 0.
   diff1 = Con(Raster(inPopSum) > 0, inBenchVal - Raster(RecPP), 0)
   diff1.save(outGDB + os.sep + outBasename + '_diffBaseline')
   
   printMsg('Calculating the difference between recreation access and excellent benchmark...')
   benchMax = inBenchVal * inBenchMax
   diff2 = Con(Raster(inPopSum) > 0, benchMax - Raster(RecPP), 0)
   diff2.save(outGDB + os.sep + outBasename + '_diffMax')
   
   printMsg('Calculating the Recreation Need to attain baseline benchmark...')
   need1 = Con(diff1 <= 0, 0, Raster(inPop) * diff1)
   need1.save(outGDB + os.sep + outBasename + '_needBaseline')
   
   printMsg('Calculating the Recreation Need to attain excellent benchmark...')
   need2 = Con(diff2 <= 0, 0, Raster(inPop) * diff2)
   need2.save(outGDB + os.sep + outBasename + '_needMax')
   
   arcpy.env.extent = hexes
   arcpy.env.mask = hexes
   
   # Aggregate raster values up to hexes
   if multiplier != 1:
      printMsg('Rescaling need for baseline benchmark...')
      needMult1 = multiplier * need1
      needMult1.save(scratch + os.sep + 'needMult1')
      need1 = needMult1
      
      printMsg('Rescaling need for excellent benchmark...')
      needMult2 = multiplier * need2
      needMult2.save(scratch + os.sep + 'needMult2')
      need2 = needMult2
      
      expression = "!SUM!/%s" % multiplier
   else:
      expression = "!SUM!"
   
   printMsg('Calculating hex sums for baseline need...')
   needTab1 = scratchGDB + os.sep + 'needTab1'
   ZonalStatisticsAsTable (hexes, hexFld, need1, needTab1, "DATA", "SUM")
   printMsg('Updating table...')
   field = outBaseName + '_bNeed'
   arcpy.AddField_management (needTab1, field, "DOUBLE")
   arcpy.CalculateField_management (needTab1, field, expression, "PYTHON")
   printMsg('Joining summary field to hexes...')
   arcpy.JoinField_management (hexes, hexFld, needTab1, hexFld, field)

   printMsg('Calculating hex sums for maximum need...')
   needTab2 = scratchGDB + os.sep + 'needTab2'
   ZonalStatisticsAsTable (hexes, hexFld, need2, needTab2, "DATA", "SUM")
   printMsg('Updating table...')
   field = outBaseName + '_mNeed'
   arcpy.AddField_management (needTab2, field, "DOUBLE")
   arcpy.CalculateField_management (needTab2, field, expression, "PYTHON")
   printMsg('Joining summary field to hexes...')
   arcpy.JoinField_management (hexes, hexFld, needTab2, hexFld, field)
   
   printMsg('Finished.')
   return hexes

# def ScoreRecNeed(inRecNeed, inPop, inCostSurf, inRadius, minNeed, outGDB, inMask, multiplier = 10000):
   # '''Consolidates pixel-level recreation need and summarizes need on broader scale.
   # Parameters:
   # - inRecNeed: Pixel-level recreation need, which is the pixel-level population multiplied by the difference between a benchmark and the per-person availailability of recreation opportunities; generated by AssessRecOpps
   # - inPop: Raster representing the number of persons per pixel
   # - inCostSurf: Raster representing time, in minutes per meter, to traverse pixels
   # - inRadius: Radius, in map units, for assessing need
   # - minNeed: Minimum value, from summing need within a contiguous zone, for the zone to be expanded by inRadius
   # - outGDB: Geodatabase for storing output products
   # - inMask: Feature layer or raster for specifying processing area
   # - multiplier: value by which to multiply inRecNeed to avoid failure during Zonal statistics calculation
   # '''
   # scratchGDB = arcpy.env.scratchGDB
   # arcpy.env.mask = inMask
   # arcpy.env.extent = inMask
   # inRecNeed = Raster(inRecNeed)
   
   # # Filter out pixels with no recreation need
   # printMsg('Filtering out pixels where there is no recreation need...')
   # needGT0 = Con(inRecNeed > 0, 1)
   # needGT0.save(scratchGDB + os.sep + 'needGT0')
   
   # # Region group filtered pixels
   # printMsg('Region-grouping remaining pixels...')
   # needRegions = RegionGroup (needGT0, "EIGHT")
   # needRegions.save(scratchGDB + os.sep + 'needRegions')
   
   # # Get zonal sums within regions
   # if multiplier != 1:
      # printMsg('Rescaling need...')
      # needMult = multiplier * inRecNeed
      # needMult.save(scratchGDB + os.sep + 'needMult')
      # inRecNeed = needMult
   # printMsg('Summing need within regions...')
   # zonalSum = ZonalStatistics (needRegions, "Value", inRecNeed, "SUM", "DATA")
   # zonalSum.save(scratchGDB + os.sep + 'zonalSum')
   # if multiplier != 1:
      # printMsg('Rescaling zonal sum back to original scale...')
      # zonalMult = zonalSum/multiplier
      # zonalMult.save(scratchGDB + os.sep + 'zonalMult')
      # zonalSum = zonalMult
   
   # # Filter out the zones below minimum need
   # printMsg('Filtering out regions with little need, and integerizing...')
   # filtZones = Con(zonalSum >= minNeed, Int(0.5 + zonalSum))
   # filtZones.save(scratchGDB + os.sep + 'filtZones')
   
   # # Cost distance on remaining zones
   # printMsg('Calculating cost distance from remaining need regions...')
   # cDist = CostDistance (filtZones, inCostSurf, 30)
   # cDist.save(scratchGDB + os.sep + 'cDist')
   
   # # Region group Cost Distance surface
   # printMsg('Consolidating travel regions...')
   # cDistCons = Con(cDist >= 0,1)
   # cDistCons.save(scratchGDB + os.sep + 'cDistCons')
   # cDistRegions = RegionGroup(cDistCons, "EIGHT")
   # cDistRegions.save(scratchGDB + os.sep + 'cDistRegions')
   
   # # Get zonal sums within regions
   # # This represents how many acres to add within regions to bring it up to benchmark
   # cDistSum = ZonalStatistics (cDistRegions, "Value", inRecNeed, "SUM", "DATA")
   # cDistSum.save(scratchGDB + os.sep + 'cDistSum')
   # if multiplier != 1:
      # printMsg('Rescaling zonal sum back to original scale...')
      # cDistMult = cDistSum/multiplier
      # cDistMult.save(scratchGDB + os.sep + 'cDistMult')
      # cDistSum = cDistMult
   
   
def TravelAccess(inTargets, inCostSurf, inSnapRaster, inMask, outTravTime, outScore, minTime = 10, maxTime = 30, limitTime = 30):
   '''Given rasterized input targets (e.g., public access lands, trails, or access points) and a cost surface, generates a raster representing the travel time in minutes to the nearest target. Also creates a score raster by linearly rescaling the travel time raster to a score from 0 to 100. Intended for use to determine local, pedestrian access.
   Parameters:
   - inTargets = Input raster representing targets to be accessed
   - inCostSurf = Input raster representing the time, in minutes, required to travel 1 meter
   - inSnapRaster = Input raster used to define coordinate system, cell size, and pixel alignment
   - inMask = Input raster or feature class used to define processing extent and analysis area
   - outTravTime = Output raster representing travel time, in minutes, to nearest target
   - outScore = Output raster representing travel time as a score from 0 to 100
   - minTime = Travel time, in minutes, below which the score should be set to 100
   - maxTime = Travel time, in minutes, above which the score should be set to 0
   - limitTime = Maximum travel time, in minutes, to be used in analysis. Any pixel more than this travel time from a target will have NoData in the OutTravTime raster, and will be set to zero in the OutScore raster
   '''
   
   # Set up processing environment
   arcpy.env.extent = inMask
   arcpy.env.mask = inMask
   arcpy.env.cellSize = inSnapRaster
   arcpy.env.snapRaster = inSnapRaster
   cellSize = arcpy.env.cellSize
   scratchGDB = arcpy.env.scratchGDB
   printMsg('Scratch products are being written to %s' %scratchGDB)
   
   # Determine travel time to targets
   printMsg('Creating travel time raster. Patience please...')
   travTime = CostDistance (inTargets, inCostSurf, limitTime)
   travTime.save(outTravTime)
   
   # Convert travel times to scores
   printMsg('Converting travel times to scores...')
   score = Con((travTime < minTime),100,Con((travTime > maxTime),0, 100*((maxTime - travTime)/(maxTime - minTime))))
   tmp1 = scratchGDB + os.sep + 'tmp1'
   score.save(tmp1)
   scoreNoNulls = Con(IsNull(score),0,score)
   tmp2 = scratchGDB + os.sep + 'tmp2'
   scoreNoNulls.save(tmp2)
   try:
      # dealing with inscrutable error here
      scoreNoNulls.save(outScore)
   except:
      ts = datetime.now().strftime("%Y%m%d_%H%M%S") #timestamp
      outScoreBAK = scratchGDB + os.sep + 'outScore_' + ts
      printMsg('Backup score raster stored here: %s' %outScoreBAK)
      arcpy.CopyRaster_management (scoreNoNulls, outScoreBAK)
   
   printMsg('Finished.')
   return (outTravTime, outScore)     

def LocalParksPP(inParks, multFactor, inRadius, inPop, outParkSum, outParksPP, inMask, popType = "SUM", outpopSum = None): 
   '''Calculates focal statistics to determine sum of parks area within a defined neighborhood radius, and then calculates the area per person.
   Parameters:
   - inParks = Input raster in which parks are indicated with the value 1
   - multFactor = Factor by which cell values should be multiplied to get the desired output units
     Example: If 30-m cells are coded 1 to indicate presence of a feature, and you want the area of features in acres, the factor is 0.222395 (1 cell = 900 sq. m = 0.222395 acres)
   - inRadius = Number representing the radius, in map units, to be used to define the neighborhood
   - inPop = Input raster representing either persons per pixel, or the sum of the population within neighborhood assumed to be same as previously specified
   - outParkSum = Output raster representing sum of park area within specified neighborhood
   - outParksPP = Output raster representing park area per person within specified neighborhood
   - inMask = Input feature class or raster defining the processing area and extent
   - popType = String indicating whether inPop represents population per pixel, or population sum within neighborhood. Options: "PIX" = per pixel, "SUM" = sum within neighborhood (default)
   - outpopSum = Output raster representing population sum within defined neighborhood, if needed
   '''
   
   arcpy.env.snapRaster = inParks # I don't know why this is necessary but it is
   arcpy.env.mask = inMask
   arcpy.env.extent = inMask
   scratchGDB = arcpy.env.scratchGDB
   
   neighborhood = NbrCircle(inRadius, "MAP")
   
   printMsg('Generating neighborhood park area sum...')
   focalSum = multFactor*FocalStatistics(inParks, neighborhood, "SUM", "DATA")
   focalSum.save(scratchGDB + os.sep + 'focalSum')
   
   printMsg('Eliminating nulls...')
   focSumNoNulls = Con(IsNull(focalSum), 0, focalSum)
   focSumNoNulls.save(outParkSum)
   
   if popType == "PIX":
      printMsg('Generating neighborhood population sum raster...')
      popSum = FocalStatistics(inPop, neighborhood, "SUM", "DATA")
      popSum.save(scratchGDB + os.sep + 'popSum')
      
      printMsg('Eliminating nulls...')
      popSumNoNulls = Con(IsNull(popSum), 0, popSum)
      
      if outpopSum == None:
         outpopSum = scratchGDB + os.sep + 'popSumNoNulls'
         printMsg('popSum raster saved in %s' %scratchGDB)
      popSumNoNulls.save(outpopSum)        
   elif popType == "SUM":
      printMsg('Proceeding under assumption that input population raster represents neighborhood population sum and is free of nulls...')
      popSumNoNulls = Raster(inPop)
   else:
      printErr('Invalid parameter value for popType; aborting...')
   
   printMsg('Calculating neighborhood recreation area per person.')   
   focalAreaPP = focSumNoNulls/popSumNoNulls
   focalAreaPP.save(outParksPP)
   
   printMsg('Finished.')
   
   return (focalSum, focalAreaPP)   
   
def LocalTrailsPP(inLines, multFactor, inRadius, inpopSum, inSnapRaster, inMask, outRaster):  
   '''Calculates the summed length of trails within a defined neighborhood radius, and then calculates the length per person.
   Parameters:
   - inLines = Input line features
   - multFactor = Factor by which line length values should be multiplied to get the desired output units
     Example: If map units are in meters, and you want the length of lines in miles, the factor is 0.000621371
   - inRadius = Radius defining the neighborhood, in map units
   - inSnapRaster = Input raster used to define coordinate system, cell size, and pixel alignment
   - inMask = Input raster or feature class used to define processing extent and analysis area
   - outRaster = Output raster representing summed line length within defined neighborhood
   '''
   
   # Set up processing environment
   arcpy.env.extent = inMask
   arcpy.env.mask = inMask
   arcpy.env.cellSize = inSnapRaster
   arcpy.env.snapRaster = inSnapRaster
   cellSize = arcpy.env.cellSize
   
   lineSum = multFactor * LineStatistics (inLines, "", cellSize, inRadius, "LENGTH")
   lineSum.save(outRaster)
   
   printMsg('Calculating neighborhood trail length per person...')   
   focalLengthPP = Raster(lineSum)/Raster(inpopSum)
   focalLengthPP.save(outRaster)
   
   printMsg('Finished.')
   
   return lineSum
     
def focalSum(inRaster, inMask, outRaster, inRadius = 2414.02, multiplier = None):
   '''Generalizes the input raster by summing values over specified neighborhood, essentially creating a heat map.
   Parameters:
   - inRaster = Input raster to be smoothed by summation
   - inMask = Input raster to determine processing area and extent
   - outRaster = Output summation raster
   - inRadius = Radius for determining neighborhood, in map units. Default is 2414.02. If map units are meters, this is equivalent to 1.5 miles.
   - multiplier = Value by which input raster values should be multiplied to avoid failure when running focal statistics. This value should be chosen that significant precision is not lost. Using a multiplier will also trigger integerization of the input.
   '''
   
   arcpy.env.extent = inMask
   arcpy.env.mask = inMask
   arcpy.env.snapRaster = inRaster
   scratchGDB = arcpy.env.scratchGDB
   neighborhood = NbrCircle(inRadius, "MAP")
   
   if multiplier != None:
      printMsg('Multiplying input by specified multiplier and integerizing...')
      multRaster = Int(0.5 + multiplier*Raster(inRaster))
      multRaster.save(scratchGDB + os.sep + 'multRaster')
      inRaster = multRaster
   
   printMsg('Smoothing raster by summation...')
   tmpRast = scratchGDB + os.sep + "focSum"
   focSum = FocalStatistics(inRaster, neighborhood, "SUM", "DATA")
   focSum.save(tmpRast)
   
   if multiplier == None:
      printMsg('Eliminating nulls and integerizing...')
      focSumNoNulls = Con(IsNull(focSum), 0, Int(0.5 + focSum))
   else:
      printMsg('Eliminating nulls, rescaling back to original scale, and integerizing...')
      focSumNoNulls = Con(IsNull(focSum), 0, Int(0.5 + focSum/multiplier))
      
   focSumNoNulls.save(outRaster)

   printMsg('Finished.')
   return focSumNoNulls
   
def zonalMean(inHex, hexFld, newFld, inRaster, inPop = None, popUpd = 0, multiplier = 1, outHex = None):
   '''From raster input, calculates mean values for zones defined by polygons. Mean is population-weighted if an input per-pixel population raster is specified.
   Parameters:
   - inHex = Input feature class with hexagons (or other regular polygons) for which raster values will be aggregated. It is assumed that this matches the coordinate system of input rasters.
   - hexFld = Field in inHex with unique IDs for each polygon
   - newFld = Name of new field to add to hexagons, containing summary value
   - inRaster = Input raster for which values should be summarized
   - inPop = Input continuous raster representing population per pixel. This may have been generated by the "DistribPop" function, or by other means. Pixel values should represent the number of persons within the pixel.
   - popUpd = Indicator as to whether the popFld should be updated (1) or not (0). If field is to be updated, inPop raster must be specified.
   - multiplier = Value by which to multiply input raster values to avoid failure during zonal statistics calculation
   - outHex = Output feature class with attributed hexagon. If "None" is specified, attributes will be added to the input feature class, and no new feature class will be created.
   '''
   
   if len(arcpy.ListFields(hexes,"PopSum"))>0:
      popExists = 1
   else:
      popExists = 0
   
   if outHex != None:
      printMsg('Copying input polygons to fresh output...')
      arcpy.Copy_management (inHex, outHex)
      hexes = outHex
   else:
      hexes = inHex
   
   arcpy.env.snapRaster = inRaster
   scratchGDB = arcpy.env.scratchGDB
   
   if multiplier != 1:
      printMsg('Multiplying input raster by specified multiplier...')
      multRast = multiplier * Raster(inRaster)
      multRast.save (scratchGDB + os.sep. + 'multRast')
      inRaster = multRast
   else:
      inRaster = Raster(inRaster)
   
   valTab = scratchGDB + os.sep + newFld   
   if inPop == None:
      printMsg('Calculating standard zonal means...')
      ZonalStatisticsAsTable (hexes, hexFld, inRaster, valTab, "DATA", "MEAN")
      arcpy.AddField_management (valTab, newFld, "DOUBLE")
      if multiplier == 1:
         expression = "!MEAN!"
      else:
         expression = "!MEAN!/%s" %str(multiplier)
      arcpy.CalculateField_management (valTab, newFld, expression, "PYTHON")
   else:
      # Calculate population sum, if needed
      if popUpd == 1 or popExists == 0:
         printMsg('Calculating population sums within polygons...')
         if popExists = 1:
            arcpy.DeleteField_management (hexes, "PopSum")
         popTab = scratchGDB + os.sep + 'popTab'
         ZonalStatisticsAsTable (hexes, hexFld, inPop, popTab, "DATA", "SUM")
         printMsg('Joining PopSum field to hexes...')
         arcpy.JoinField_management (hexes, hexFld, popTab, hexFld, "PopSum")
      else 
         printMsg('Using existing values in PopSum field...')
      
      printMsg('Multiplying population by input raster...')
      calcRast = Raster(inPop)*inRaster
      calcRast.save(scratchGDB + os.sep + 'calcRast')
      
      printMsg('Calculating zonal sum...')
      ZonalStatisticsAsTable (hexes, hexFld, calcRast, valTab, "DATA", "SUM")
      
      printMsg('Calculating population-weighted average...)
      arcpy.JoinField_management (valTab, hexFld, hexes, hexFld, "PopSum")
      arcpy.AddField_management (valTab, newFld, "DOUBLE")
      if multiplier == 1:
         expression = "!SUM!/!PopSum!"
      else:
         expression = "(!SUM!/%s)/!PopSum!" %str(multiplier)
      arcpy.CalculateField_management (valTab, newFld, expression, "PYTHON")
      
   printMsg('Joining summary field to hexes...')
   arcpy.JoinField_management (hexes, hexFld, valTab, hexFld, newFld)
   
def main():
   # Kirsten's Stuff
   # Set up variables
   inTargets_parks = r'F:\Working\RecMod\FinalDataToUse\rec_source_datasets.gdb\pub_lands_final_20190221'
   parksRaster = r'F:\Working\RecMod\Outputs\Products.gdb\allParks_raster'
   #inTargets = r'F:\Working\RecMod\FinalDataToUse\rec_source_datasets.gdb\trails_include_20190221'
   inCostSurf = r'F:\Working\RecMod\FinalDataToUse\cost_surfaces_Tiger_2018\cost_surfaces.gdb\costSurf_walk'
   inSnapRaster = r'F:\Working\Snap_AlbersCONUS30\Snap_AlbersCONUS30.tif'
   inMask = r'F:\Working\VA_Buff50mi\VA_Buff50mi.shp'
   outTravTime = r'F:\Working\RecMod\Outputs\Products.gdb\WalkTime_Parks2'
   #outTravTime = r'F:\Working\RecMod\Outputs\Products.gdb\WalkTime_Trails2'
   outScore = r'F:\Working\RecMod\Outputs\Products.gdb\WalkScore_Parks2'
   #outScore = r'F:\Working\RecMod\Outputs\Products.gdb\WalkScore_Trails2'
   BenchVal_regParks = 0.010 # 10 acres per 1000 people = 0.010 acres/person
   BenchVal_locParks = 0.003 # 3 acres per 1000 people = 0.003 acres/person
   inPop = r'F:\Working\RecMod\FinalDataToUse\RoadsPopProducts.gdb\distribPop_kdens'
   #inRecPP_parks = r'F:\Working\RecMod\FinalDataToUse\raw_summary_scores.gdb\popAdj_sum_t_tlnd_serviceAreas'
   regParksPP = r'F:\Working\RecMod\Outputs\regParks_RecPP.tif'
   outDir = r'F:\Working\RecMod\Outputs'
   inRadUnits = "MAP"
   inRadius = 2414.02 # 1.5 miles = 2414.02 meters
   pix2acre = 0.222395 # multiplier to convert pixel area to acres
   locParkSum = r'F:\Working\RecMod\Outputs\Products.gdb\locParkSum'
   locPopSum = r'F:\Working\RecMod\Outputs\Products.gdb\locPopSum'
   locParksPP = r'F:\Working\RecMod\Outputs\Products.gdb\locParksPP'
   locParksRecNeed = r'F:\Working\RecMod\Outputs\locParks_RecNeed.tif'
   locParksRecNeedSum = r'F:\Working\RecMod\Outputs\Products.gdb\locParks_RecNeedSum'
   regParksRecNeed = r'F:\Working\RecMod\Outputs\regParks_RecNeed.tif'
   #regParksRecNeedSum = r'F:\Working\RecMod\Outputs\Products.gdb\regParks_RecNeedSum'
   regParksRecNeedSum = r'F:\Working\RecMod\Outputs\Products.gdb\regParks_RecNeedSum30mile'
   outGDB = r'F:\Working\RecMod\Outputs\Products_20190228.gdb'
   countyMask = r'F:\Working\RecMod\FinalDataToUse\VA_Counties2018.shp'
   
   
   # Specify function(s) to run
   #TravelAccess(inTargets, inCostSurf, inSnapRaster, inMask, outTravTime, outScore, minTime = 10, maxTime = 30, limitTime = 30)
   #AssessRecOpps(inBenchVal, inPop, inRecPP, inPubAccess, outDir, outBasename, inMask = None)
   
   # Convert features to raster
   #FeatToRaster(inTargets_parks, inSnapRaster, inMask, parksRaster)
   
   # RecOpps for parks:
   # AssessRecOpps(BenchVal_regParks, inPop, inRecPP_parks, parksRaster, outDir, "regParks", inMask)
   # AssessRecOpps(BenchVal_regParks, inPop, regParksPP, parksRaster, outDir, "regParks10", 0, inMask)
   # LocalParksPP(parksRaster, pix2acre, inRadius, inPop, locParkSum, locParksPP, inMask, "PIX", locPopSum)
   # AssessRecOpps(BenchVal_locParks, inPop, locPopSum, locParksPP, "LOCAL", parksRaster, outDir, "locParks", inMask)
   #focalSum(locParksRecNeed, inMask, locParksRecNeedSum, 2414.02, 1000000)
   #focalSum(regParksRecNeed, inMask, regParksRecNeedSum, 2414.02, 1000000)
   # focalSum(regParksRecNeed, inMask, regParksRecNeedSum, 48280, 1000000)
   AssessRecOpps(BenchVal_regParks, inPop, locPopSum, regParksPP, parksRaster, outGDB, "regParks", countyMask)

if __name__ == '__main__':
   main()
