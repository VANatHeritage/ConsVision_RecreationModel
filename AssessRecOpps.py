#--------------------------------------------------------------------------------------
# AssessRecOpps.py
# Version:  ArcGIS 10.3.1 / Python 2.7.8
# Creation Date: 2018-10-04
# Last Edit: 2019-02-27
# Creator:  Kirsten R. Hazler
#
# Summary:
# Assesses adequacy of recreation opportunities based on facilities' service areas, population, and specified benchmark standards.
#
# Usage:
# 

# TO DO: 
# - Change all outputs to go into a FGDB. Some operations (notably, focal statistics) fail when outputting to TIF!
# - Add option for a multiplier and integerization to focalSum function. Focal statistics can fail miserably depending on values in input raster. For local RecNeed, I multiplied by 1000 and integerized to get it to work properly.
#--------------------------------------------------------------------------------------
# Import Helper module and functions
import Helper
from Helper import *
from arcpy import env

def FeatToRaster(inFeatures, inSnapRaster, inMask, outRaster):
   '''Given point, line, or polygon features, generates a raster representing those features
   Parameters:
   - inFeatures = Input point, line, or polygon feature class
   - inSnapRaster = Input raster used to define coordinate system, cell size, and pixel alignment
   - inMask = Input raster or feature class used to define processing extent and analysis area
   - outRaster = Output raster representing input features
   '''
   
   # Set up processing environment
   arcpy.env.extent = inMask
   arcpy.env.mask = inMask
   arcpy.env.cellSize = inSnapRaster
   arcpy.env.snapRaster = inSnapRaster
   cellSize = arcpy.env.cellSize
   scratchGDB = arcpy.env.scratchGDB
   printMsg('Scratch products are being written to %s' %scratchGDB)
   
   # Convert features to raster according to shape type
   printMsg('Converting features to a raster...')
   arcpy.AddField_management (inFeatures, "RasterVal", "SHORT")
   arcpy.CalculateField_management (inFeatures, "RasterVal", "1", "PYTHON")
   desc = arcpy.Describe(inFeatures)
   shapeType = desc.shapeType
   if shapeType in ('Point, Multipoint'):
      arcpy.PointToRaster_conversion (inFeatures, "RasterVal", outRaster, "MAXIMUM", "RasterVal", cellSize)
   elif shapeType == 'Polyline':
      arcpy.PolylineToRaster_conversion (inFeatures, "RasterVal", outRaster, "MAXIMUM_COMBINED_LENGTH", "RasterVal", cellSize)
   elif shapeType == 'Polygon':
      arcpy.PolygonToRaster_conversion (inFeatures, "RasterVal", outRaster, "MAXIMUM_COMBINED_AREA", "RasterVal", cellSize)
   else:
      printErr('Not sure to do with this feature type. Aborting...')
      
   printMsg('Finished.')
   
   return outRaster

   
def QuantRecOpps(inDir, inPop, outRecPP, tmpDir, zeroRast = ''):
   '''Quantifies recreation opportunities accessed per person, based on facilities' service areas and population.
   
   inDir = input folder containing service area rasters to be processed. It is assumed these are continuous rasters in TIF format. Each service area should be coded with the value (e.g., area or trail length) of the entity, and the raster should be coded NoData (null) outside the service area.
   
   inPop = input continuous raster representing population per pixel. This may have been generated by the "DistribPop" function, or other means. Pixel values should represent the number of persons within the pixel.
   
   outRecPP = output raster representing per-person sum of available recreation access (area or length)
   
   [eliminated variable] outRecOpps = output raster representing population-weighted sum of available recreation access (area or length). This is the raster to be compared against the benchmark raster.
   
   tmpDir = directory to contain temporary outputs
   
   zeroRast = a raster coded with zeros whereever the "inPop" raster is non-null
   '''
   
   # Apply environment settings
   arcpy.env.snapRaster = inPop
   arcpy.env.cellSize = inPop
   arcpy.env.extent = inPop
   arcpy.env.mask = inPop
   
   # Set up some output variables
   if zeroRast == '':
      zeroRast = tmpDir + os.sep + 'zeros.tif'
      
   # Create baseline zeros raster
   if arcpy.Exists(zeroRast):
      printMsg('Zero raster already exists. Proceeding to next step...')
   else:
      printMsg('Creating zero raster...')
      tmpRast = Con(inPop, 0)
      tmpRast.save(zeroRast)
      printMsg('Zero raster created.')
      
   # Initialize some objects
   arcpy.env.workspace = inDir
   ServAreas = arcpy.ListRasters() # List of service areas to process
   myRastList = [zeroRast] # List to store paths to rasters to be summed
   myFailList = [] # List to store names of rasters failing to be processed
   myIndex = 1 # counter
   
   # For each service area:
   for sa in ServAreas:
      try:
         arcpy.env.extent = sa
         printMsg('Working on %s...' % sa) 
      
         # Integerize the service area
         intSA = tmpDir + os.sep + "intSA.tif"
         tmpRast = Con(sa,1)
         tmpRast.save(intSA)
         printMsg('Service area integerized.')

         # Get sum of population within service area
         sumPop = tmpDir + os.sep + "sumPop.tif"
         tmpRast = ZonalStatistics(intSA, "Value", inPop, "SUM", "DATA") 
         tmpRast.save(sumPop)
         printMsg('Population summed.')
         
         # Get the recreation area (or length) per person
         recPP = tmpDir + os.sep + "recPP_%05d.tif" % myIndex
         tmpRast = Raster(sa)/Raster(sumPop)
         tmpRast.save(recPP)
         printMsg('Per person rec opps calculated.')
         
         myRastList.append(recPP)
         printMsg('Processing for %s complete.' % sa)
         
      except:
         printMsg('Processing for %s failed.' % sa)
         myFailList.append(sa)
         
      finally:
         myIndex += 1
         try:
            del sa, intSA, sumPop, recPP
         except:
            pass
   
   # Sum the areas (or lengths) accessed per person
   printMsg('Summing all rasters to get per-person recreation access. This will take awhile...')
   arcpy.env.extent = inPop
   tmpRast = CellStatistics(myRastList, "SUM", "DATA")
   tmpRast.save(outRecPP)
   printMsg('Finished summing rasters.')
   
   # # Calculate the population-weighted areas (or lengths) accessed
   # printMsg('Calculating population-weighted recreation access...')
   # tmpRast = Raster(inPop)* Raster(outRecPP)
   # tmpRast.save(outRecOpps)
   printMsg('Mission accomplished.')
   
   return outRecPP
   
def AssessRecOpps(inBenchVal, inPop, inPopSum, inRecPP, recType, inPubAccess, outDir, outBasename, inMask, inBenchMax = 5):
   '''Compares estimated recreation access to a benchmark to determine where recreation resources meet or exceed desired levels, and where attention is needed to offer additional resources.
   Parameters:
   - inBenchVal = Input value representing the desired area (or length) of recreational facilities, per person. 
      For parks, the value suggested is 10 acres per 1000 people = 0.010 acres/person = 0.004 ha/person. This is based on communications with DCR-PRR staff; see "rule of thumb" email chain started 10/3/2018
      
      For trails, the value suggested is 1 mile per 2500 people = 1.61 km per 2500 people = 0.0006 km/person. This is based on the "Trails, Nature" line item in a chart provided by DCR-PRR staff; see email from J. Wampler on 10/5/2018.
   - inPop = input continuous raster representing population per pixel. This may have been generated by the "DistribPop" function, or by other means. Pixel values should represent the number of persons within the pixel.
   - inPopSum = Input raster representing population sum within defined neighborhood (typically, 1.5 miles)
   - inRecPP = Input raster representing per-person sum of available recreation access (area or length)
   - recType = specifies whether inRecPP is from a "REGIONAL" or "LOCAL" analysis
   - inPubAccess = Input raster indicating public lands with any value; all other pixels must be null
   - outDir = Directory to contain output products
   - outBasename = Basename (string) for output products
   - inMask = (optional) mask used to determine processing area
   - inBenchMax = multiplier by which inBenchVal is multiplied to obtain a standard for "excellent"
   '''
   
   arcpy.env.extent = inMask
   arcpy.env.mask = inPopSum
   
   if recType == "REGIONAL":
      printMsg('Updating regional per-person recreation raster to eliminate nulls in populated areas...')
      RecPP = outDir + os.sep + outBasename + "_RecPP.tif"
      ppNoNulls = Con(IsNull(inRecPP), 0, inRecPP)
      ppNoNulls.save(RecPP)
   else:
      printMsg('Assuming input per-person recreation raster has no nulls to remove. Proceeding...')
      RecPP = inRecPP
   
   arcpy.env.extent = inMask
   
   printMsg('Calculating the Recreation Access Score...')
   # Note: With this formula, a pixel just meeting the minimum standard will get a score of 20. Anything meeting or exceeding five times the standard will get the maximum score of 100. Anyplace where the local population sum is 0 will be NoData.
   tmpScore = Con(Raster(inPopSum) > 0, 100*Raster(RecPP)/(inBenchMax*float(inBenchVal)))
   score = Con(IsNull(inPubAccess),(Con(tmpScore > 100, 100, tmpScore)), 101)
   RecScore = outDir + os.sep + outBasename + "_RecScore.tif"
   score.save(RecScore)
   
   printMsg('Calculating the Recreation Need...')
   need = Con(IsNull(inPop), 0, Con(score >= 20, 0, Raster(inPop) * (float(inBenchVal) - Raster(RecPP))))
   #need = Con(score < 20, Raster(inPop) * (float(inBenchVal) - Raster(RecPP)))
   RecNeed = outDir + os.sep + outBasename + "_RecNeed.tif"
   need.save(RecNeed)
   
   # Possibly add further steps here to classify and symbolize output?
   
   printMsg('Finished.')
   return (RecScore, RecNeed)
   
def TravelAccess(inTargets, inCostSurf, inSnapRaster, inMask, outTravTime, outScore, minTime = 10, maxTime = 30, limitTime = 30):
   '''Given rasterized input targets (e.g., public access lands, trails, or access points) and a cost surface, generates a raster representing the travel time in minutes to the nearest target. Also creates a score raster by linearly rescaling the travel time raster to a score from 0 to 100. Intended for use to determine local, pedestrian access.
   Parameters:
   - inTargets = Input raster representing targets to be accessed
   - inCostSurf = Input raster representing the time, in minutes, required to travel 1 meter
   - inSnapRaster = Input raster used to define coordinate system, cell size, and pixel alignment
   - inMask = Input raster or feature class used to define processing extent and analysis area
   - outTravTime = Output raster representing travel time, in minutes, to nearest target
   - outScore = Output raster representing travel time as a score from 0 to 100
   - minTime = Travel time, in minutes, below which the score should be set to 100
   - maxTime = Travel time, in minutes, above which the score should be set to 0
   - limitTime = Maximum travel time, in minutes, to be used in analysis. Any pixel more than this travel time from a target will have NoData in the OutTravTime raster, and will be set to zero in the OutScore raster
   '''
   
   # Set up processing environment
   arcpy.env.extent = inMask
   arcpy.env.mask = inMask
   arcpy.env.cellSize = inSnapRaster
   arcpy.env.snapRaster = inSnapRaster
   cellSize = arcpy.env.cellSize
   scratchGDB = arcpy.env.scratchGDB
   printMsg('Scratch products are being written to %s' %scratchGDB)
   
   # Determine travel time to targets
   printMsg('Creating travel time raster. Patience please...')
   travTime = CostDistance (inTargets, inCostSurf, limitTime)
   travTime.save(outTravTime)
   
   # Convert travel times to scores
   printMsg('Converting travel times to scores...')
   score = Con((travTime < minTime),100,Con((travTime > maxTime),0, 100*((maxTime - travTime)/(maxTime - minTime))))
   tmp1 = scratchGDB + os.sep + 'tmp1'
   score.save(tmp1)
   scoreNoNulls = Con(IsNull(score),0,score)
   tmp2 = scratchGDB + os.sep + 'tmp2'
   scoreNoNulls.save(tmp2)
   try:
      # dealing with inscrutable error here
      scoreNoNulls.save(outScore)
   except:
      ts = datetime.now().strftime("%Y%m%d_%H%M%S") #timestamp
      outScoreBAK = scratchGDB + os.sep + 'outScore_' + ts
      printMsg('Backup score raster stored here: %s' %outScoreBAK)
      arcpy.CopyRaster_management (scoreNoNulls, outScoreBAK)
   
   printMsg('Finished.')
   return (outTravTime, outScore)     

def LocalParksPP(inParks, multFactor, inRadius, inPop, outParkSum, outParksPP, inMask, popType = "SUM", outpopSum = None): 
   '''Calculates focal statistics to determine sum of parks area within a defined neighborhood radius, and then calculates the area per person.
   Parameters:
   - inParks = Input raster in which parks are indicated with the value 1
   - multFactor = Factor by which cell values should be multiplied to get the desired output units
     Example: If 30-m cells are coded 1 to indicate presence of a feature, and you want the area of features in acres, the factor is 0.222395 (1 cell = 900 sq. m = 0.222395 acres)
   - inRadius = Number representing the radius, in map units, to be used to define the neighborhood
   - inPop = Input raster representing either persons per pixel, or the sum of the population within neighborhood assumed to be same as previously specified
   - outParkSum = Output raster representing sum of park area within specified neighborhood
   - outParksPP = Output raster representing park area per person within specified neighborhood
   - inMask = Input feature class or raster defining the processing area and extent
   - popType = String indicating whether inPop represents population per pixel, or population sum within neighborhood. Options: "PIX" = per pixel, "SUM" = sum within neighborhood (default)
   - outpopSum = Output raster representing population sum within defined neighborhood, if needed
   '''
   
   arcpy.env.snapRaster = inParks # I don't know why this is necessary but it is
   arcpy.env.mask = inMask
   arcpy.env.extent = inMask
   scratchGDB = arcpy.env.scratchGDB
   
   neighborhood = NbrCircle(inRadius, "MAP")
   
   printMsg('Generating neighborhood park area sum...')
   focalSum = multFactor*FocalStatistics(inParks, neighborhood, "SUM", "DATA")
   focalSum.save(scratchGDB + os.sep + 'focalSum')
   
   printMsg('Eliminating nulls...')
   focSumNoNulls = Con(IsNull(focalSum), 0, focalSum)
   focSumNoNulls.save(outParkSum)
   
   if popType == "PIX":
      printMsg('Generating neighborhood population sum raster...')
      popSum = FocalStatistics(inPop, neighborhood, "SUM", "DATA")
      popSum.save(scratchGDB + os.sep + 'popSum')
      
      printMsg('Eliminating nulls...')
      popSumNoNulls = Con(IsNull(popSum), 0, popSum)
      
      if outpopSum == None:
         outpopSum = scratchGDB + os.sep + 'popSumNoNulls'
         printMsg('popSum raster saved in %s' %scratchGDB)
      popSumNoNulls.save(outpopSum)        
   elif popType == "SUM":
      printMsg('Proceeding under assumption that input population raster represents neighborhood population sum and is free of nulls...')
      popSumNoNulls = Raster(inPop)
   else:
      printErr('Invalid parameter value for popType; aborting...')
   
   printMsg('Calculating neighborhood recreation area per person.')   
   focalAreaPP = focSumNoNulls/popSumNoNulls
   focalAreaPP.save(outParksPP)
   
   printMsg('Finished.')
   
   return (focalSum, focalAreaPP)   
   
def LocalTrailsPP(inLines, multFactor, inRadius, inpopSum, inSnapRaster, inMask, outRaster):  
   '''Calculates the summed length of trails within a defined neighborhood radius, and then calculates the length per person.
   Parameters:
   - inLines = Input line features
   - multFactor = Factor by which line length values should be multiplied to get the desired output units
     Example: If map units are in meters, and you want the length of lines in miles, the factor is 0.000621371
   - inRadius = Radius defining the neighborhood, in map units
   - inSnapRaster = Input raster used to define coordinate system, cell size, and pixel alignment
   - inMask = Input raster or feature class used to define processing extent and analysis area
   - outRaster = Output raster representing summed line length within defined neighborhood
   '''
   
   # Set up processing environment
   arcpy.env.extent = inMask
   arcpy.env.mask = inMask
   arcpy.env.cellSize = inSnapRaster
   arcpy.env.snapRaster = inSnapRaster
   cellSize = arcpy.env.cellSize
   
   lineSum = multFactor * LineStatistics (inLines, "", cellSize, inRadius, "LENGTH")
   lineSum.save(outRaster)
   
   printMsg('Calculating neighborhood trail length per person...')   
   focalLengthPP = Raster(lineSum)/Raster(inpopSum)
   focalLengthPP.save(outRaster)
   
   printMsg('Finished.')
   
   return lineSum
     
def focalSum(inRaster, inMask, outRaster, inRadius = 2414.02, multiplier = None):
   '''Generalizes the input raster by summing values over specified neighborhood, essentially creating a heat map.
   Parameters:
   - inRaster = Input raster to be smoothed by summation
   - inMask = Input raster to determine processing area and extent
   - outRaster = Output summation raster
   - inRadius = Radius for determining neighborhood, in map units. Default is 2414.02. If map units are meters, this is equivalent to 1.5 miles.
   - multiplier = Value by which input raster values should be multiplied to avoid failure when running focal statistics. This value should be chosen that significant precision is not lost. Using a multiplier will also trigger integerization of the input.
   '''
   
   arcpy.env.extent = inMask
   arcpy.env.mask = inMask
   arcpy.env.snapRaster = inRaster
   scratchGDB = arcpy.env.scratchGDB
   neighborhood = NbrCircle(inRadius, "MAP")
   
   if multiplier != None:
      printMsg('Multiplying input by specified multiplier and integerizing...')
      multRaster = Int(0.5 + multiplier*Raster(inRaster))
      multRaster.save(scratchGDB + os.sep + 'multRaster')
      inRaster = multRaster
   
   printMsg('Smoothing raster by summation...')
   tmpRast = scratchGDB + os.sep + "focSum"
   focSum = FocalStatistics(inRaster, neighborhood, "SUM", "DATA")
   focSum.save(tmpRast)
   
   if multiplier == None:
      printMsg('Eliminating nulls and integerizing...')
      focSumNoNulls = Con(IsNull(focSum), 0, Int(0.5 + focSum))
   else:
      printMsg('Eliminating nulls, rescaling back to original scale, and integerizing...')
      focSumNoNulls = Con(IsNull(focSum), 0, Int(0.5 + focSum/multiplier))
      
   focSumNoNulls.save(outRaster)

   printMsg('Finished.')
   return focSumNoNulls
   
def main():
   # Kirsten's Stuff
   # Set up variables
   inTargets_parks = r'F:\Working\RecMod\FinalDataToUse\rec_source_datasets.gdb\pub_lands_final_20190221'
   parksRaster = r'F:\Working\RecMod\Outputs\Products.gdb\allParks_raster'
   #inTargets = r'F:\Working\RecMod\FinalDataToUse\rec_source_datasets.gdb\trails_include_20190221'
   inCostSurf = r'F:\Working\RecMod\FinalDataToUse\cost_surfaces_Tiger_2018\cost_surfaces.gdb\costSurf_walk'
   inSnapRaster = r'F:\Working\Snap_AlbersCONUS30\Snap_AlbersCONUS30.tif'
   inMask = r'F:\Working\VA_Buff50mi\VA_Buff50mi.shp'
   outTravTime = r'F:\Working\RecMod\Outputs\Products.gdb\WalkTime_Parks2'
   #outTravTime = r'F:\Working\RecMod\Outputs\Products.gdb\WalkTime_Trails2'
   outScore = r'F:\Working\RecMod\Outputs\Products.gdb\WalkScore_Parks2'
   #outScore = r'F:\Working\RecMod\Outputs\Products.gdb\WalkScore_Trails2'
   BenchVal_regParks = 0.010 # 10 acres per 1000 people = 0.010 acres/person
   BenchVal_locParks = 0.003 # 3 acres per 1000 people = 0.003 acres/person
   inPop = r'F:\Working\RecMod\FinalDataToUse\RoadsPopProducts.gdb\distribPop_kdens'
   #inRecPP_parks = r'F:\Working\RecMod\FinalDataToUse\raw_summary_scores.gdb\popAdj_sum_t_tlnd_serviceAreas'
   regParksPP = r'F:\Working\RecMod\Outputs\regParks_RecPP.tif'
   outDir = r'F:\Working\RecMod\Outputs'
   inRadUnits = "MAP"
   inRadius = 2414.02 # 1.5 miles = 2414.02 meters
   pix2acre = 0.222395 # multiplier to convert pixel area to acres
   locParkSum = r'F:\Working\RecMod\Outputs\Products.gdb\locParkSum'
   locPopSum = r'F:\Working\RecMod\Outputs\Products.gdb\locPopSum'
   locParksPP = r'F:\Working\RecMod\Outputs\Products.gdb\locParksPP'
   locParksRecNeed = r'F:\Working\RecMod\Outputs\locParks_RecNeed.tif'
   locParksRecNeedSum = r'F:\Working\RecMod\Outputs\Products.gdb\locParks_RecNeedSum'
   regParksRecNeed = r'F:\Working\RecMod\Outputs\regParks_RecNeed.tif'
   #regParksRecNeedSum = r'F:\Working\RecMod\Outputs\Products.gdb\regParks_RecNeedSum'
   regParksRecNeedSum = r'F:\Working\RecMod\Outputs\Products.gdb\regParks_RecNeedSum30mile'
   
   
   # Specify function(s) to run
   #TravelAccess(inTargets, inCostSurf, inSnapRaster, inMask, outTravTime, outScore, minTime = 10, maxTime = 30, limitTime = 30)
   #AssessRecOpps(inBenchVal, inPop, inRecPP, inPubAccess, outDir, outBasename, inMask = None)
   
   # Convert features to raster
   #FeatToRaster(inTargets_parks, inSnapRaster, inMask, parksRaster)
   
   # RecOpps for parks:
   # AssessRecOpps(BenchVal_regParks, inPop, inRecPP_parks, parksRaster, outDir, "regParks", inMask)
   # AssessRecOpps(BenchVal_regParks, inPop, regParksPP, parksRaster, outDir, "regParks10", 0, inMask)
   # LocalParksPP(parksRaster, pix2acre, inRadius, inPop, locParkSum, locParksPP, inMask, "PIX", locPopSum)
   # AssessRecOpps(BenchVal_locParks, inPop, locPopSum, locParksPP, "LOCAL", parksRaster, outDir, "locParks", inMask)
   #focalSum(locParksRecNeed, inMask, locParksRecNeedSum, 2414.02, 1000000)
   #focalSum(regParksRecNeed, inMask, regParksRecNeedSum, 2414.02, 1000000)
   focalSum(regParksRecNeed, inMask, regParksRecNeedSum, 48280, 1000000)

if __name__ == '__main__':
   main()
