#--------------------------------------------------------------------------------------
# AssessRecOpps.py
# Version:  ArcGIS 10.3.1 / Python 2.7.8
# Creation Date: 2018-10-04
# Last Edit: 2019-03-07
# Creator:  Kirsten R. Hazler
#
# Summary:
# Assesses adequacy of recreation opportunities based on facilities' service areas, population, and specified benchmark standards.
#
# Usage:
# 

# TO DO: 
# - Change all outputs to go into a FGDB. Some operations (notably, focal statistics) fail when outputting to TIF!
# - Add option for a multiplier and integerization to focalSum function. Focal statistics can fail miserably depending on values in input raster. For local RecNeed, I multiplied by 1000 and integerized to get it to work properly.
#--------------------------------------------------------------------------------------
# Import Helper module and functions
import Helper
from Helper import *
from arcpy import env


def FeatToRaster(inFeatures, inSnapRaster, inMask, outRaster):
   '''Given point, line, or polygon features, generates a raster representing those features
   Parameters:
   - inFeatures = Input point, line, or polygon feature class
   - inSnapRaster = Input raster used to define coordinate system, cell size, and pixel alignment
   - inMask = Input raster or feature class used to define processing extent and analysis area
   - outRaster = Output raster representing input features
   '''
   
   # Set up processing environment
   arcpy.env.extent = inMask
   arcpy.env.mask = inMask
   arcpy.env.cellSize = inSnapRaster
   arcpy.env.snapRaster = inSnapRaster
   cellSize = arcpy.env.cellSize
   scratchGDB = arcpy.env.scratchGDB
   printMsg('Scratch products are being written to %s' %scratchGDB)
   
   # Convert features to raster according to shape type
   printMsg('Converting features to a raster...')
   arcpy.AddField_management (inFeatures, "RasterVal", "SHORT")
   arcpy.CalculateField_management (inFeatures, "RasterVal", "1", "PYTHON")
   desc = arcpy.Describe(inFeatures)
   shapeType = desc.shapeType
   if shapeType in ('Point, Multipoint'):
      arcpy.PointToRaster_conversion (inFeatures, "RasterVal", outRaster, "MAXIMUM", "RasterVal", cellSize)
   elif shapeType == 'Polyline':
      arcpy.PolylineToRaster_conversion (inFeatures, "RasterVal", outRaster, "MAXIMUM_COMBINED_LENGTH", "RasterVal", cellSize)
   elif shapeType == 'Polygon':
      arcpy.PolygonToRaster_conversion (inFeatures, "RasterVal", outRaster, "MAXIMUM_COMBINED_AREA", "RasterVal", cellSize)
   else:
      printErr('Not sure to do with this feature type. Aborting...')
      
   printMsg('Finished.')
   
   return outRaster

   
def QuantRecOpps(inDir, inPop, outRecPP, tmpDir, zeroRast = ''):
   '''Quantifies recreation opportunities accessed per person, based on facilities' service areas and population.
   
   inDir = input folder containing service area rasters to be processed. It is assumed these are continuous rasters in TIF format. Each service area should be coded with the value (e.g., area or trail length) of the entity, and the raster should be coded NoData (null) outside the service area.
   
   inPop = input continuous raster representing population per pixel. This may have been generated by the "DistribPop" function, or other means. Pixel values should represent the number of persons within the pixel.
   
   outRecPP = output raster representing per-person sum of available recreation access (area or length)
   
   [eliminated variable] outRecOpps = output raster representing population-weighted sum of available recreation access (area or length). This is the raster to be compared against the benchmark raster.
   
   tmpDir = directory to contain temporary outputs
   
   zeroRast = a raster coded with zeros whereever the "inPop" raster is non-null
   '''
   
   # Apply environment settings
   arcpy.env.snapRaster = inPop
   arcpy.env.cellSize = inPop
   arcpy.env.extent = inPop
   arcpy.env.mask = inPop
   
   # Set up some output variables
   if zeroRast == '':
      zeroRast = tmpDir + os.sep + 'zeros.tif'
      
   # Create baseline zeros raster
   if arcpy.Exists(zeroRast):
      printMsg('Zero raster already exists. Proceeding to next step...')
   else:
      printMsg('Creating zero raster...')
      tmpRast = Con(inPop, 0)
      tmpRast.save(zeroRast)
      printMsg('Zero raster created.')
      
   # Initialize some objects
   arcpy.env.workspace = inDir
   ServAreas = arcpy.ListRasters() # List of service areas to process
   myRastList = [zeroRast] # List to store paths to rasters to be summed
   myFailList = [] # List to store names of rasters failing to be processed
   myIndex = 1 # counter
   
   # For each service area:
   for sa in ServAreas:
      try:
         arcpy.env.extent = sa
         printMsg('Working on %s...' % sa) 
      
         # Integerize the service area
         intSA = tmpDir + os.sep + "intSA.tif"
         tmpRast = Con(sa,1)
         tmpRast.save(intSA)
         printMsg('Service area integerized.')

         # Get sum of population within service area
         sumPop = tmpDir + os.sep + "sumPop.tif"
         tmpRast = ZonalStatistics(intSA, "Value", inPop, "SUM", "DATA") 
         tmpRast.save(sumPop)
         printMsg('Population summed.')
         
         # Get the recreation area (or length) per person
         recPP = tmpDir + os.sep + "recPP_%05d.tif" % myIndex
         tmpRast = Raster(sa)/Raster(sumPop)
         tmpRast.save(recPP)
         printMsg('Per person rec opps calculated.')
         
         myRastList.append(recPP)
         printMsg('Processing for %s complete.' % sa)
         
      except:
         printMsg('Processing for %s failed.' % sa)
         myFailList.append(sa)
         
      finally:
         myIndex += 1
         try:
            del sa, intSA, sumPop, recPP
         except:
            pass
   
   # Sum the areas (or lengths) accessed per person
   printMsg('Summing all rasters to get per-person recreation access. This will take awhile...')
   arcpy.env.extent = inPop
   tmpRast = CellStatistics(myRastList, "SUM", "DATA")
   tmpRast.save(outRecPP)
   printMsg('Finished summing rasters.')
   
   # # Calculate the population-weighted areas (or lengths) accessed
   # printMsg('Calculating population-weighted recreation access...')
   # tmpRast = Raster(inPop)* Raster(outRecPP)
   # tmpRast.save(outRecOpps)
   printMsg('Mission accomplished.')
   
   return outRecPP
   
def AssessRecNeed(inHex, hexFld, inBenchVal, inPop, inRecPP, inMask, outGDB, outBasename, inBenchMax = 5, remNulls = 0, multiplier = 10000, outHex = None):
   '''Compares estimated recreation access (in terms of acreage of parks, mileage of trails, or numbers of access points) to benchmarks to determine where recreation resources meet desired levels, and where attention is needed to offer additional resources.
   Parameters:
   - inHex = Input feature class with hexagons (or other regular polygons) for which raster values will be aggregated. It is assumed that this matches the coordinate system of input rasters.
   - hexFld = Field in inHex with unique IDs for each polygon
   - inBenchVal = Input value representing the desired area (or length) of recreational facilities, per person. 
      For regional parks, the value suggested is 10 acres per 1000 people = 0.010 acres/person = 0.004 ha/person. This is based on communications with DCR-PRR staff; see "rule of thumb" email chain started 10/3/2018
      
      For trails, the value suggested is 1 mile per 2500 people = 1.61 km per 2500 people = 0.0006 km/person. This is based on the "Trails, Nature" line item in a chart provided by DCR-PRR staff; see email from J. Wampler on 10/5/2018.
   - inPop = input continuous raster representing population per pixel. This may have been generated by the "DistribPop" function, or by other means. Pixel values should represent the number of persons within the pixel.
   - inRecPP = Input raster representing per-person sum of available recreation access (area or length)
   - inMask = mask used to determine processing area. Best to standard raster processing boundary.
   - outGDB = Geodatabase to contain output products
   - outHex = Output feature class with attributed hexagaons. If None, the original input feature class will be altered.
   - outBasename = Basename (string) for output products
   - inBenchMax = Multiplier by which inBenchVal is multiplied to obtain a standard for "excellent"
   - remNulls = Specifies whether inRecPP needs nulls to be removed. Options: 1 = Nulls need to be removed (typical for regional input if not pre-processed); 0 = Nulls do not need to be removed (typical for local input, or if regional data already pre-processed; default)
   - multiplier = Value by which to multiply per-person recreation access values to avoid failure during zonal statistics calculation
   - outHex = Output feature class with attributed hexagon. If "None" is specified, attributes will be added to the input feature class, and no new feature class will be created.
   '''
   
   if outHex != None:
      printMsg('Copying input polygons to fresh output...')
      arcpy.Copy_management (inHex, outHex)
      hexes = outHex
   else:
      hexes = inHex
      
   arcpy.env.extent = inMask
   arcpy.env.mask = inMask
   arcpy.env.snapRaster = inRecPP
   scratchGDB = arcpy.env.scratchGDB
   
   if remNulls == 1:
      printMsg('Updating per-person recreation raster to eliminate nulls in populated areas...')
      RecPP = outGDB + os.sep + outBasename + "_RecPP"
      ppNoNulls = Con(Raster(inPop)>0, Con(IsNull(inRecPP), 0, inRecPP))
      ppNoNulls.save(RecPP)
   else:
      printMsg('Assuming input per-person recreation raster has no nulls to remove. Proceeding...')
      RecPP = inRecPP
   
   # Calculate need rasters
   # Need is the amount of acres of parks, miles of trails, or numbers of aquatic access points needed to meet the benchmark for the number of people
   printMsg('Calculating the difference between recreation access and baseline benchmark...')
   # Note: Anyplace where the local population is 0 is considered to have no need and assigned the value 0.
   diff1 = Con(Raster(inPop) > 0, inBenchVal - Raster(RecPP), 0)
   diff1.save(scratchGDB + os.sep + outBasename + '_diffBaseline')
   
   printMsg('Calculating the difference between recreation access and excellent benchmark...')
   benchMax = inBenchVal * inBenchMax
   diff2 = Con(Raster(inPop) > 0, benchMax - Raster(RecPP), 0)
   diff2.save(scratchGDB + os.sep + outBasename + '_diffMax')
   
   printMsg('Calculating the Recreation Need to attain baseline benchmark...')
   need1 = Con(diff1 <= 0, 0, Raster(inPop) * diff1)
   need1.save(outGDB + os.sep + outBasename + '_needBaseline')
   
   printMsg('Calculating the Recreation Need to attain excellent benchmark...')
   need2 = Con(diff2 <= 0, 0, Raster(inPop) * diff2)
   need2.save(outGDB + os.sep + outBasename + '_needMax')
   
   arcpy.env.extent = hexes
   arcpy.env.mask = hexes
   
   # Aggregate raster values up to hexes
   if multiplier != 1:
      printMsg('Rescaling need for baseline benchmark...')
      needMult1 = multiplier * need1
      needMult1.save(scratchGDB + os.sep + outBasename + '_needBaseline_x%s'%str(multiplier))
      need1 = needMult1
      
      printMsg('Rescaling need for excellent benchmark...')
      needMult2 = multiplier * need2
      needMult2.save(scratchGDB + os.sep + outBasename + '_needMax_x%s'%str(multiplier))
      need2 = needMult2
      
      expression = "!SUM!/%s" % multiplier
   else:
      expression = "!SUM!"
   
   printMsg('Calculating hex sums for baseline need...')
   needTab1 = scratchGDB + os.sep + 'needTab1'
   ZonalStatisticsAsTable (hexes, hexFld, need1, needTab1, "DATA", "SUM")
   printMsg('Updating table...')
   field = outBasename + '_bNeed'
   arcpy.AddField_management (needTab1, field, "DOUBLE")
   arcpy.CalculateField_management (needTab1, field, expression, "PYTHON")
   printMsg('Joining summary field to hexes...')
   arcpy.JoinField_management (hexes, hexFld, needTab1, hexFld, field)

   printMsg('Calculating hex sums for maximum need...')
   needTab2 = scratchGDB + os.sep + 'needTab2'
   ZonalStatisticsAsTable (hexes, hexFld, need2, needTab2, "DATA", "SUM")
   printMsg('Updating table...')
   field = outBasename + '_mNeed'
   arcpy.AddField_management (needTab2, field, "DOUBLE")
   arcpy.CalculateField_management (needTab2, field, expression, "PYTHON")
   printMsg('Joining summary field to hexes...')
   arcpy.JoinField_management (hexes, hexFld, needTab2, hexFld, field)
   
   printMsg('Finished.')
   return hexes

def TravelAccess(inTargets, inCostSurf, inSnapRaster, inMask, outTravTime, outScore, minTime = 10, maxTime = 30, limitTime = 30):
   '''Given rasterized input targets (e.g., public access lands, trails, or access points) and a cost surface, generates a raster representing the travel time in minutes to the nearest target. Also creates a score raster by linearly rescaling the travel time raster to a score from 0 to 100. Intended for use to determine local, pedestrian access.
   Parameters:
   - inTargets = Input raster representing targets to be accessed
   - inCostSurf = Input raster representing the time, in minutes, required to travel 1 meter
   - inSnapRaster = Input raster used to define coordinate system, cell size, and pixel alignment
   - inMask = Input raster or feature class used to define processing extent and analysis area
   - outTravTime = Output raster representing travel time, in minutes, to nearest target
   - outScore = Output raster representing travel time as a score from 0 to 100
   - minTime = Travel time, in minutes, below which the score should be set to 100
   - maxTime = Travel time, in minutes, above which the score should be set to 0
   - limitTime = Maximum travel time, in minutes, to be used in analysis. Any pixel more than this travel time from a target will have NoData in the OutTravTime raster, and will be set to zero in the OutScore raster
   '''
   
   # Set up processing environment
   arcpy.env.extent = inMask
   arcpy.env.mask = inMask
   arcpy.env.cellSize = inSnapRaster
   arcpy.env.snapRaster = inSnapRaster
   cellSize = arcpy.env.cellSize
   scratchGDB = arcpy.env.scratchGDB
   printMsg('Scratch products are being written to %s' %scratchGDB)
   
   # Determine travel time to targets
   printMsg('Creating travel time raster. Patience please...')
   travTime = CostDistance (inTargets, inCostSurf, limitTime)
   travTime.save(outTravTime)
   
   # Convert travel times to scores
   printMsg('Converting travel times to scores...')
   score = Con((travTime < minTime),100,Con((travTime > maxTime),0, 100*((maxTime - travTime)/(maxTime - minTime))))
   tmp1 = scratchGDB + os.sep + 'tmp1'
   score.save(tmp1)
   scoreNoNulls = Con(IsNull(score),0,score)
   tmp2 = scratchGDB + os.sep + 'tmp2'
   scoreNoNulls.save(tmp2)
   try:
      # dealing with inscrutable error here
      scoreNoNulls.save(outScore)
   except:
      ts = datetime.now().strftime("%Y%m%d_%H%M%S") #timestamp
      outScoreBAK = scratchGDB + os.sep + 'outScore_' + ts
      printMsg('Backup score raster stored here: %s' %outScoreBAK)
      arcpy.CopyRaster_management (scoreNoNulls, outScoreBAK)
   
   printMsg('Finished.')
   return (outTravTime, outScore)     

def LocalParksPP(inParks, multFactor, inRadius, inPop, outParkSum, outParksPP, inMask, popType = "SUM", outpopSum = None): 
   '''Calculates focal statistics to determine sum of parks area within a defined neighborhood radius, and then calculates the area per person.
   Parameters:
   - inParks = Input raster in which parks are indicated with the value 1
   - multFactor = Factor by which cell values should be multiplied to get the desired output units
     Example: If 30-m cells are coded 1 to indicate presence of a feature, and you want the area of features in acres, the factor is 0.222395 (1 cell = 900 sq. m = 0.222395 acres)
   - inRadius = Number representing the radius, in map units, to be used to define the neighborhood
   - inPop = Input raster representing either persons per pixel, or the sum of the population within neighborhood assumed to be same as previously specified
   - outParkSum = Output raster representing sum of park area within specified neighborhood
   - outParksPP = Output raster representing park area per person within specified neighborhood
   - inMask = Input feature class or raster defining the processing area and extent
   - popType = String indicating whether inPop represents population per pixel, or population sum within neighborhood. Options: "PIX" = per pixel, "SUM" = sum within neighborhood (default)
   - outpopSum = Output raster representing population sum within defined neighborhood, if needed
   '''
   
   arcpy.env.snapRaster = inParks # I don't know why this is necessary but it appears to be
   arcpy.env.mask = inMask
   arcpy.env.extent = inMask
   scratchGDB = arcpy.env.scratchGDB
   
   neighborhood = NbrCircle(inRadius, "MAP")
   
   printMsg('Generating neighborhood park area sum...')
   focalSum = multFactor*FocalStatistics(inParks, neighborhood, "SUM", "DATA")
   focalSum.save(scratchGDB + os.sep + 'focalSum')
   
   printMsg('Eliminating nulls...')
   focSumNoNulls = Con(IsNull(focalSum), 0, focalSum)
   focSumNoNulls.save(outParkSum)
   
   if popType == "PIX":
      printMsg('Generating neighborhood population sum raster...')
      popSum = FocalStatistics(inPop, neighborhood, "SUM", "DATA")
      popSum.save(scratchGDB + os.sep + 'popSum')
      
      printMsg('Eliminating nulls...')
      popSumNoNulls = Con(IsNull(popSum), 0, popSum)
      
      if outpopSum == None:
         outpopSum = scratchGDB + os.sep + 'popSumNoNulls'
         printMsg('popSum raster saved in %s' %scratchGDB)
      popSumNoNulls.save(outpopSum)        
   elif popType == "SUM":
      printMsg('Proceeding under assumption that input population raster represents neighborhood population sum and is free of nulls...')
      popSumNoNulls = Raster(inPop)
   else:
      printErr('Invalid parameter value for popType; aborting...')
   
   printMsg('Calculating neighborhood recreation area per person.')   
   focalAreaPP = focSumNoNulls/popSumNoNulls
   focalAreaPP.save(outParksPP)
   
   printMsg('Finished.')
   
   return (focSumNoNulls, focalAreaPP)   
   
def LocalTrailsPP(inLines, multFactor, inRadius, inPopSum, inSnapRaster, inMask, outSum, outPP):  
   '''Calculates the summed length of trails within a defined neighborhood radius, and then calculates the length per person.
   Parameters:
   - inLines = Input line features
   - multFactor = Factor by which line length values should be multiplied to get the desired output units
     Example: If map units are in meters, and you want the length of lines in miles, the factor is 0.000621371
   - inRadius = Radius defining the neighborhood, in map units
   - inPopSum = focal sum of population in neighborhood defined by inRadius
   - inSnapRaster = Input raster used to define coordinate system, cell size, and pixel alignment
   - inMask = Input raster or feature class used to define processing extent and analysis area
   - outSum = Output raster representing summed line length within focal neighborhoods
   - outPP = Output raster representing length per person within focal neighborhoods
   '''
   
   # Set up processing environment
   arcpy.env.extent = inMask
   arcpy.env.mask = inMask
   arcpy.env.cellSize = inSnapRaster
   arcpy.env.snapRaster = inSnapRaster
   cellSize = arcpy.env.cellSize
   
   printMsg('Calculating line length in neighborhoods...')
   # Lessons learned: (1) Using None or "None" or "" as the second parameter in LineStatistics bombs. (2) Using any other field results in multiplying actual lengths by arbitrary number in field (= disaster unless that field is set to 1).
   lineSum = multFactor * LineStatistics (inLines, "NONE", cellSize, inRadius, "LENGTH")
   lineSum.save(outSum)
   
   printMsg('Calculating neighborhood trail length per person...')   
   focalLengthPP = Raster(outSum)/Raster(inPopSum)
   focalLengthPP.save(outPP)
   
   printMsg('Finished.')
   
   return (lineSum,focalLengthPP)
     
def focalSum(inRaster, inMask, outRaster, inRadius = 2414.02, multiplier = None):
   '''Generalizes the input raster by summing values over specified neighborhood, essentially creating a heat map.
   Parameters:
   - inRaster = Input raster to be smoothed by summation
   - inMask = Input raster to determine processing area and extent
   - outRaster = Output summation raster
   - inRadius = Radius for determining neighborhood, in map units. Default is 2414.02. If map units are meters, this is equivalent to 1.5 miles.
   - multiplier = Value by which input raster values should be multiplied to avoid failure when running focal statistics. This value should be chosen that significant precision is not lost. Using a multiplier will also trigger integerization of the input.
   '''
   
   arcpy.env.extent = inMask
   arcpy.env.mask = inMask
   arcpy.env.snapRaster = inRaster
   scratchGDB = arcpy.env.scratchGDB
   neighborhood = NbrCircle(inRadius, "MAP")
   
   if multiplier != None:
      printMsg('Multiplying input by specified multiplier and integerizing...')
      multRaster = Int(0.5 + multiplier*Raster(inRaster))
      multRaster.save(scratchGDB + os.sep + 'multRaster')
      inRaster = multRaster
   
   printMsg('Smoothing raster by summation...')
   tmpRast = scratchGDB + os.sep + "focSum"
   focSum = FocalStatistics(inRaster, neighborhood, "SUM", "DATA")
   focSum.save(tmpRast)
   
   if multiplier == None:
      printMsg('Eliminating nulls and integerizing...')
      focSumNoNulls = Con(IsNull(focSum), 0, Int(0.5 + focSum))
   else:
      printMsg('Eliminating nulls, rescaling back to original scale, and integerizing...')
      focSumNoNulls = Con(IsNull(focSum), 0, Int(0.5 + focSum/multiplier))
      
   focSumNoNulls.save(outRaster)

   printMsg('Finished.')
   return focSumNoNulls
   
def zonalMean(inHex, hexFld, newFld, inRaster, remNulls = 0, repVal = 0, inPop = None, popUpd = 0, multiplier = 1, unitUpdate = 1, outHex = None):
   '''From raster input, calculates mean values for zones defined by polygons. Mean is population-weighted if an input per-pixel population raster is specified.
   Parameters:
   - inHex = Input feature class with hexagons (or other regular polygons) for which raster values will be aggregated. It is assumed that this matches the coordinate system of input rasters.
   - hexFld = Field in inHex with unique IDs for each polygon
   - newFld = Name of new field to add to hexagons, containing summary value
   - inRaster = Input raster for which values should be summarized
   - remNulls = Indicator of whether nulls should be converted to zeros in output field
   - remVal = Value to use for replacing nulls, if applicable
   - inPop = Input continuous raster representing population per pixel. This may have been generated by the "DistribPop" function, or by other means. Pixel values should represent the number of persons within the pixel.
   - popUpd = Indicator as to whether the popFld should be updated (1) or not (0). If field is to be updated, inPop raster must be specified.
   - multiplier = Value by which to multiply input raster values to avoid failure during zonal statistics calculation. 
   - unitUpdate = Value by which to multiply final output values to get desired units
   - outHex = Output feature class with attributed hexagon. If "None" is specified, attributes will be added to the input feature class, and no new feature class will be created.
   '''
   
   if outHex != None:
      printMsg('Copying input polygons to fresh output...')
      arcpy.Copy_management (inHex, outHex)
      hexes = outHex
   else:
      hexes = inHex
   
   if len(arcpy.ListFields(hexes,"PopSum"))>0:
      popExists = 1
   else:
      popExists = 0
      
   if len(arcpy.ListFields(hexes,newFld))>0:
      fldExists = 1
   else:
      fldExists = 0
      
   arcpy.env.snapRaster = inRaster
   scratchGDB = arcpy.env.scratchGDB
   
   if multiplier != 1:
      printMsg('Multiplying input raster by specified multiplier...')
      multRast = multiplier * Raster(inRaster)
      multRast.save (scratchGDB + os.sep + 'multRast')
      inRaster = multRast
   else:
      inRaster = Raster(inRaster)
   
   valTab = scratchGDB + os.sep + newFld   
   if inPop == None:
      printMsg('Calculating standard zonal means...')
      ZonalStatisticsAsTable (hexes, hexFld, inRaster, valTab, "DATA", "MEAN")
      arcpy.AddField_management (valTab, newFld, "DOUBLE")
      if multiplier == 1:
         expression = "!MEAN!"
      else:
         expression = "!MEAN!/%s" %str(multiplier)
      arcpy.CalculateField_management (valTab, newFld, expression, "PYTHON")
   else:
      # Calculate population sum, if needed
      if popUpd == 1 or popExists == 0:
         printMsg('Calculating population sums within polygons...')
         if popExists == 1:
            arcpy.DeleteField_management (hexes, "PopSum")
         popTab = scratchGDB + os.sep + 'popTab'
         ZonalStatisticsAsTable (hexes, hexFld, inPop, popTab, "DATA", "SUM")
         arcpy.AddField_management (popTab, "PopSum", "DOUBLE")
         arcpy.CalculateField_management (popTab, "PopSum", "!SUM!", "PYTHON")
         # expression = "remNulls(!PopSum!)"
         # codeblock = '''def remNulls(fld):
            # if fld == None:
               # return 0
            # else:
               # return fld'''
         # arcpy.CalculateField_management (popTab, "PopSum", expression, "PYTHON", codeblock)
         printMsg('Joining PopSum field to hexes...')
         arcpy.JoinField_management (hexes, hexFld, popTab, hexFld, "PopSum")
      else: 
         printMsg('Using existing values in PopSum field...')
      
      printMsg('Multiplying population by input raster...')
      calcRast = Raster(inPop)*inRaster
      calcRast.save(scratchGDB + os.sep + 'calcRast')
      
      printMsg('Calculating zonal sum...')
      ZonalStatisticsAsTable (hexes, hexFld, calcRast, valTab, "DATA", "SUM")
      
      printMsg('Calculating population-weighted average...')
      arcpy.JoinField_management (valTab, hexFld, hexes, hexFld, "PopSum")
      arcpy.AddField_management (valTab, newFld, "DOUBLE")
      if multiplier == 1:
         expression = "!SUM!/!PopSum!"
      else:
         expression = "(!SUM!/%s)/!PopSum!" %str(multiplier)
      arcpy.CalculateField_management (valTab, newFld, expression, "PYTHON")
      
      if remNulls == 1:
         expression = "remNulls(!%s!)"%newFld
         codeblock = '''def remNulls(fld):
            if fld == None:
               return %s
            else:
               return fld'''%str(repVal)
         arcpy.CalculateField_management (valTab, newFld, expression, "PYTHON", codeblock)
         
   printMsg('Joining %s to hexes...' %newFld)
   if fldExists == 1:
      arcpy.DeleteField_management (hexes, newFld)
   arcpy.JoinField_management (hexes, hexFld, valTab, hexFld, newFld)
   
   if unitUpdate !=1:
      printMsg('Updating values to get desired units...')
      expression = "!%s! * %s" %(newFld, str(unitUpdate))
      arcpy.CalculateField_management (hexes, newFld, expression, "PYTHON")
   
   printMsg('Done.')
   return hexes

def travelBinary(inTravTime, cutoff, inPop, outBinRaster, outCleanRaster = None, repVal = None):
   '''If specified, removes nulls from an input travel time raster, replacing them with specified value. Then converts to a binary raster based on specified cutoff. Any cells with travel time less than or equal to the cutoff are set to 1, everything else set to zero. Any cells without population are set to null.
   Parameters:
   - inTravTime = Input raster representing travel time (usually in minutes)
   - cutoff = Maximum travel time, beyond which output raster is set to null
   - inPop = Input raster representing population as persons per cell
   - outBinRaster = Output binary raster, where travel times less than cutoff are set to 1
   - outCleanRaster = Output "clean" travel time raster where nulls have been replaced with specified value
   - repVal = Value to replace nulls in clean travel time raster
   '''
   travTime = Raster(inTravTime)
   arcpy.env.mask = inPop
   arcpy.env.extent = inPop
   
   if repVal != None:
      printMsg('Filling in nulls in input raster...')
      cleanTT = Con(IsNull(travTime), repVal, travTime)
      cleanTT.save(outCleanRaster)
      travTime = cleanTT
   
   printMsg('Creating binary raster...')
   binRast = Con(inPop > 0, Con(IsNull(travTime), 0, Con(travTime < cutoff, 1, 0)))
   binRast.save(outBinRaster)
   
   printMsg('Done.')
   
   return outBinRaster

def updateNulls(inHex, valFld, repVal, popFld = "PopSum"):
   '''Updates null values in the specified field with a specified replacement value. If the population value field is specified, the values will be updated only for those records where population is greater than zero.
   Parameters:
   - inHex = Input polygon feature class with hexagons or other units
   - ttFld = Field containing travel time value
   - repVal = Value to use to replace nulls, where applicable
   - popFld = Field containing population value, or None if it is not to be used
   '''
   printMsg('Updating nulls...')
   if popFld != None:
      codeblock = '''def remNulls(valFld, popFld):
         if valFld == None:
            if popFld > 0:
               return %s
            else:
               return None
         else:
            return valFld
         '''%str(repVal)
      expression = "remNulls(!%s!,!%s!)"%(valFld, popFld)
      
   else:
      codeblock = '''def remNulls(valFld):
         if valFld == None:
            return %s
         else:
            return valFld
         '''%str(repVal)
      expression = "remNulls(!%s!)"%(valFld)
      
   arcpy.CalculateField_management (inHex, valFld, expression, "PYTHON", codeblock)
   printMsg('Done.')
   
def main():
   # Parameters
   inHex = r'F:\Working\RecMod\Outputs\Products_20190306.gdb\attribHex_1pt5mile'
   trlHex = r'F:\Working\RecMod\Outputs\Products_20190306.gdb\attribHex_Trails'
   hexFld = 'Unique_ID'
   inPop = r'F:\Working\RecMod\FinalDataToUse\RoadsPopProducts.gdb\distribPop_kdens'
   inMask = r'F:\Working\VA_Buff50mi\VA_Buff50mi.shp'
   outGDB = r'F:\Working\RecMod\Outputs\Products_20190306.gdb'
   multiplier = 10000
   cell2acres = 0.222395
   rPrkBenchVal = 0.010 # 10 acres per 1000 people
   lPrkBenchVal = 0.003 # 3 acres per 1000 people
   rTrlBenchVal = 0.0004 # 1 mile per 2500 people
   lTrlBenchVal = 0.0000133 # 1 mile per 7500 people
   inRadius = 2414.02 # 1.5 miles = 2414.02 meters

   # rTrl_recPP = r'F:\Working\RecMod\FinalDataToUse\raw_summary_scores.gdb\popAdj_sum_t_ttrl_serviceAreas'
   rTrl_recPP = r'F:\Working\RecMod\Outputs\Products_20190306.gdb\rTrl_RecPP'
   rTrl_sum = r'F:\Working\RecMod\FinalDataToUse\raw_summary_scores.gdb\servArea_sum_t_ttrl_serviceAreas'
   rTrl_tt = r'F:\Working\RecMod\FinalDataToUse\regional_access_all_60min_ServiceAreas.gdb\grp_ttrl_servArea'
   rTrl_ttBin = r'F:\Working\RecMod\Outputs\Products_20190306.gdb\rTrl_tt30'
   
   # Functions to run
   # AssessRecNeed(inHex, hexFld, rTrlBenchVal, inPop, rTrl_recPP, inMask, outGDB, "rTrl", 5, 1, 1000000, trlHex)
   # zonalMean(trlHex, hexFld, "rTrl_Acc", rTrl_sum, 1, 0)
   # zonalMean(trlHex, hexFld, "rTrl_p75C", rTrl_recPP, 0, 0, inPop, 0, 1000000, 7500)
   travelBinary(rTrl_tt, 30, inPop, rTrl_ttBin)
   zonalMean(trlHex, hexFld, "rTrl_tt30", rTrl_ttBin, 0, 0, inPop)
   zonalMean(trlHex, hexFld, "rTrl_ttAvg", rTrl_tt, 0, 0, inPop)
   updateNulls(trlHex, "rTrl_ttAvg", 61, "PopSum")
   
   
if __name__ == '__main__':
   main()
